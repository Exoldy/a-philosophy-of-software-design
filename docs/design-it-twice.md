# **11. Проектируй дважды (Design it Twice)**

**(Потому что твоя первая идея — говно)**

Проектирование софта — это боль, страдания и тлен. Поэтому вероятность того, что твоя первая гениальная мысль о структуре модуля окажется чем-то вменяемым, стремится к нулю. Ты получишь результат гораздо лучше, если рассмотришь несколько вариантов для каждого важного решения. Короче: **спроектируй это дважды**.

Допустим, ты пилишь класс, который будет управлять текстом файла для GUI-редактора. Первый шаг — определить интерфейс, который этот класс вывалит наружу для остальной части редактора. Вместо того чтобы хвататься за первую идею, которая пришла в твою светлую голову, рассмотри несколько вариантов.

1.  **Построчный интерфейс (Line-oriented):** операции вставки, изменения и удаления целых строк.
2.  **Посимвольный интерфейс:** вставка и удаление отдельных символов.
3.  **Строковый интерфейс (String-oriented):** работа с произвольными диапазонами символов, которые могут пересекать границы строк.

Тебе не нужно расписывать каждую фичу до мелочей, достаточно просто набросать основные методы на салфетке, чтобы понять, взлетит или нет.

Постарайся выбрать подходы, которые **радикально, блять, отличаются** друг от друга. Так ты узнаешь больше. Даже если ты уверен, что существует только один разумный подход (потому что ты у мамы самый умный), всё равно придумай второй дизайн, каким бы убогим он тебе ни казался. Будет полезно подумать о слабостях этого "убогого" дизайна и сравнить их с фичами других вариантов.

После того как ты накидал черновики, составь список плюсов и минусов для каждого. Самое важное соображение для интерфейса — **насколько удобно этим говном пользоваться** коду более высокого уровня.

В примере выше и построчный, и посимвольный интерфейсы заставят писать лишний код снаружи:
*   **Построчный:** заставит код верхнего уровня ебаться с разделением и склейкой строк при операциях типа cut/paste.
*   **Посимвольный:** заставит писать циклы для любой операции, затрагивающей больше одного символа.

Также стоит подумать о других факторах:
*   У какого варианта интерфейс проще? (В примере с текстом они все вроде бы простые).
*   Какой интерфейс более универсален?
*   Какой интерфейс позволит реализовать всё это эффективно? (Спойлер: посимвольный подход, скорее всего, будет тормозить как твоя бывшая, потому что требует отдельного вызова на каждый, сука, символ).

---

Как только ты сравнишь альтернативы, ты будешь в лучшем положении, чтобы выбрать победителя. Лучшим выбором может стать один из вариантов, или ты внезапно поймешь, что можно скрестить ужа с ежом и получить новый дизайн, который лучше всех исходных.

Иногда бывает так, что все варианты — полное говно. Когда это случается, попробуй придумать новые схемы. Используй проблемы, которые ты нашел в первых вариантах, как топливо для нового дизайна.

Если бы ты проектировал класс текста и рассматривал только построчный и посимвольный подходы, ты бы заметил, что оба они кривые, потому что заставляют внешний код делать грязную работу. Это, блять, **тревожный звоночек (Red Flag)**: если уж ты делаешь класс для текста, он должен сам разгребать всё дерьмо с манипуляциями текстом. Чтобы избавиться от лишней возни снаружи, интерфейс должен плотнее соответствовать тому, что реально нужно приложению. А эти операции не всегда укладываются в "один символ" или "одна строка". Эта логическая цепочка должна привести тебя к **range-oriented API** (интервальному подходу), который решает проблемы предыдущих дизайнов.

Принцип "спроектируй дважды" можно применять везде.
Для модуля — сначала выбери интерфейс. Потом примени его снова, когда будешь думать над реализацией: связный список строк, блоки фиксированного размера или "gap buffer" (буфер с дыркой). Цели реализации отличаются от целей интерфейса: тут главное простота и производительность, чтобы оно летало. Также полезно перебирать варианты на высоких уровнях, например, при выборе фич для UI или при разбивке системы на крупные модули. Всегда проще найти лучший путь, если есть с чем сравнивать.

"Проектирование дважды" не требует дохера времени. Для небольшого класса тебе хватит часа-двух, чтобы обмозговать варианты. Это ничтожно мало по сравнению с теми днями или неделями, которые ты потратишь на кодинг (и последующий рефакторинг, если выберешь херню). Эксперименты на старте окупятся с лихвой. Для крупных модулей времени уйдет больше, но и профит от хорошего дизайна там выше.

### **Проблема "слишком умных"**

Я заметил, что принцип "спроектируй дважды" очень туго заходит реально умным людям.

Пока они растут и учатся, эти "сверхразумы" привыкают, что их первая же идея достаточно хороша, чтобы получить "отлично" в зачетку. Нет нужды думать над вторым или третьим вариантом. Это вырабатывает херовые рабочие привычки. Однако, когда эти люди взрослеют и попадают в реальный мир (сюрприз, блять!), задачи становятся сложнее. В конце концов, все упираются в потолок, где первой идеи уже недостаточно. Если хочешь реально крутых результатов — изволь придумать второй вариант, и похер, насколько ты умен. Проектирование крупных систем — это как раз та категория: **никто не настолько крут, чтобы сделать всё правильно с первого раза**.

К сожалению, я часто вижу умников, которые с пеной у рта настаивают на реализации первой пришедшей в голову идеи. Это заставляет их работать хуже своего потенциала (а еще с ними пиздец как сложно работать, они бесят). Возможно, они подсознательно верят, что "умные люди делают всё правильно с первого раза", поэтому, если они пробуют несколько вариантов, это типа значит, что они тупые.

Это не так. Дело не в том, что ты тупой, а в том, что задачи, сука, сложные! И это даже хорошо: гораздо интереснее решать сложную задачу, где надо шевелить извилинами, чем клепать формочки, где думать вообще не надо.

Подход "спроектируй дважды" не только улучшает твой дизайн, но и качает твой скилл. Процесс сравнения подходов научит тебя видеть факторы, которые делают дизайн хорошим или куском говна. Со временем тебе станет проще отсеивать лажу и сразу целиться в нормальные решения.