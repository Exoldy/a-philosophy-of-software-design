# **2. Суть всей боли (Природа Сложности)**

Эта книга о том, как проектировать системы так, чтобы не хотелось выколоть себе глаза при попытке внести правки. Первый шаг — узнать врага в лицо. Что за херня эта «сложность»? Как понять, что система переусложнена без веской причины? Откуда вообще берется этот бардак? В этой главе мы обсосем эти вопросы с высоты птичьего полета, а дальше будем разбираться, как находить конкретные куски говна в коде.

Умение видеть сложность — это, блять, важнейший скилл дизайнера. Это позволяет заметить проблему до того, как ты вбухаешь в неё неделю работы. Понять, что дизайн — говно, проще, чем родить хороший дизайн с нуля. Но если ты научишься чувствовать запах плохого кода, твой внутренний компас сам выведет тебя к простоте. Если что-то выглядит сложно — попробуй сделать иначе. Со временем ты поймешь: одни приемы делают жизнь проще, а другие — это путевка в ад.

Здесь мы заложим фундамент. Дальше по книге я буду опираться на эти тезисы как на аксиомы, чтобы доказывать, почему одни решения норм, а другие — полный отстой.

## **2.1 Чё это такое вообще (Определение)**

Будем прагматиками. **Сложность — это любая херня в структуре софта, которая мешает его понимать и править.**

У сложности много лиц.
*   Трудно понять, как работает этот кусок кода? Сложно.
*   Чтобы поправить мелкий баг, нужно перелопатить полпроекта? Сложно.
*   Непонятно, где именно надо править, чтобы фича заработала? Сложно.
*   Фиксишь одно, а отваливается другое? Поздравляю, у вас сложность.

Если систему сложно понять и изменить — она сложная. Если легко — она простая. Всё, блять, гениальное просто.

Можно смотреть на это через призму «цена/качество». В сложной системе даже мелкое улучшение стоит титанических усилий. В простой системе ты делаешь много полезного малой кровью.

Сложность — это то, что чувствует программист в моменте. Это не обязательно про размер проекта. Бывают огромные системы, с которыми приятно работать (редкость, но бывает). А бывает маленький скрипт на 100 строк, от которого хочется повеситься.

Сложность определяется тем, где вы чаще всего ковыряетесь. Если в системе есть кусок адского легаси, но его никто не трогает годами — это не страшно.
Математически это выглядит так:

$$
C=\sum_{p}c_pt_p
$$

Общая сложность ($C$) — это сумма сложности каждой части ($c_p$), умноженная на то, сколько времени ($t_p$) ты тратишь на еблю с этой частью. Если говнокод изолирован и забыт — считай, его нет.

**Важный момент:** Сложность видна читателю, а не писателю. Если ты написал код и тебе всё понятно, а твой коллега смотрит на него как баран на новые ворота и говорит, что это сложно — **значит, это сложно**. Не надо спорить, надо спросить, что именно вызывает боль. Твоя задача — писать код не для себя любимого, а чтобы другие не проклинали тебя, когда будут это читать.

## **2.2 Симптомы (Как понять, что вы в глубокой жопе)**

Сложность вылезает в трех основных формах. Каждая из них делает твою работу невыносимой.

**1. Эффект дробовика (Change Amplification)**
Это когда ты хочешь поменять одну мелочь, а приходится править код в ста местах.
*Пример:* Древний веб-сайт. Фон страницы прописан хардкодом в каждом из 5000 HTML-файлов (рис. 2.1а). Захотел поменять цвет? Ебись вручную с каждым файлом.
*Нормальный подход:* Цвет задан в одном месте (CSS или переменная), все страницы ссылаются туда (рис. 2.1b). Одна правка — глобальный эффект. Цель хорошего дизайна — чтобы изменения были локальными, а не размазывались тонким слоем по всему проекту.

**2. Когнитивная перегрузка (Cognitive Load)**
Это объем инфы, который тебе нужно загрузить в мозг, чтобы выполнить задачу. Чем больше грузишь, тем выше шанс, что ты что-то забудешь и накосячишь.
*Пример:* Функция на C выделяет память и возвращает указатель, но не освобождает её. Теперь вызывающий код *обязан* знать, что память надо освободить, иначе будет утечка. Это лишняя нагрузка на мозг. Если бы функция сама убирала за собой, жить было бы проще.
Перегрузку создают: раздутые интерфейсы, глобальные переменные, нелогичные зависимости.

*Миф:* Многие думают, что меньше строк кода = проще. **Хер там плавал.** Иногда нужно написать больше кода, чтобы разгрузить мозг того, кто будет это использовать. Фреймворк, где всё делается магически в две строки, может быть адовым для понимания, потому что ты ни хера не знаешь, что там происходит под капотом.

![](./figures/00010.jpeg)
*Рис 2.1: Эволюция геморроя. (a) Хардкод везде — смерть. (b) Общая переменная — норм. (c) Внезапная зависимость (тень) — скрытая подлянка.*

**3. Неведомая ёбаная хуйня (Unknown Unknowns)**
Самый страшный симптом. Это когда ты даже не знаешь, что тебе нужно что-то знать, чтобы сделать правку.
*Пример:* Ты меняешь цвет фона (как в пункте 1), всё вроде ок. Но оказывается, на некоторых страницах есть ещё «тень» фона, которая задана жестко и должна сочетаться с основным цветом (рис. 2.1c). Ты меняешь фон, тень остается старой, дизайн выглядит как говно. Но ты об этом не узнаешь, пока не откроешь ту самую страницу.
При «эффекте дробовика» ты хотя бы знаешь, что надо много править. При «когнитивной нагрузке» ты знаешь, что надо много учить. А тут ты действуешь вслепую. Единственный способ застраховаться — прочитать весь код системы, что нереально.

Хороший дизайн делает всё **очевидным**. Ты смотришь на код и сразу врубаешься, что и где менять, и уверен, что ничего не сломаешь.

## **2.3 Кто виноват и что делать (Причины)**

Итак, почему всё так плохо? Есть два всадника Апокалипсиса: **Зависимости** и **Непонятки (Obscurity)**.

**Зависимости**
Это когда один кусок кода не может жить без другого. Поменял тут — проверяй там.
В примере с сайтом (2.1a) все страницы зависели от конкретного кода цвета. В новой версии (2.1b) мы убрали зависимость страниц друг от друга, но создали зависимость от переменной `bannerBg`.
*Нюанс:* Совсем без зависимостей нельзя, это ж софт. Но мы должны делать их простыми и очевидными. Зависимость от одной переменной лучше, чем копипаста по всему проекту. Компилятор хотя бы скажет тебе, если ты удалишь переменную.

**Непонятки (Obscurity)**
Это когда важная инфа скрыта или неочевидна.
*   Переменная называется `data`? Спасибо, блять, очень информативно.
*   В документации не указаны единицы измерения? Удачи угадать, секунды там или миллисекунды.
*   Зависимость есть, но её не видно. Например, сообщение об ошибке формируется из таблицы, о существовании которой ты даже не догадываешься.

Часто это лечится документацией, но лучше лечить это дизайном. Если код требует талмуда документации, чтобы понять, как он работает — это хуёвый дизайн.

Зависимости приводят к тому, что правки расползаются и мозг кипит. Непонятки создают «неведомую хуйню». Убей эти две причины — и код станет проще.

## **2.4 Почему оно растет как снежный ком (Сложность инкрементальна, сука)**

Сложность не возникает внезапно из-за одной ошибки. Она накапливается.
Это смерть от тысячи порезов. Тут накостылял, там переменную назвал `x`, здесь добавил неявную зависимость. Кажется, что каждая мелочь — фигня, «потом поправлю».
Но со временем эти мелочи скапливаются в огромный ком грязи. И вот уже любое изменение вызывает боль.
Сложность инкрементальна. Если каждый разработчик будет думать «ай, и так сойдёт» про свои мелкие правки, проект обречен. Нужна **нулевая терпимость** к говнокоду (об этом в главе 3).

## **2.5 Итог: Жизнь — боль**

Сложность — это накопление зависимостей и мутных мест.
Она приводит к трем стадиям принятия неизбежного:
1.  Приходится править дохера файлов ради одной фичи.
2.  Голова взрывается от количества контекста.
3.  Ты даже не знаешь, где рванёт в следующий раз.

Результат: писать код становится долго, дорого и страшно.