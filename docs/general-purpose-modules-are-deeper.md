# **6. Универсальность модулей (General Purpose)**

Одно из самых частых решений, над которым приходится ломать голову при дизайне нового модуля: пилить его **универсальным** (general-purpose) или заточить под **конкретную задачу** (special-purpose)?

Одни мамкины архитекторы будут топить за универсальный подход: мол, давай запилим механизм, который решит не только сегодняшние проблемы, но и вообще все возможные проблемы человечества. Типа, вдруг в будущем пригодится, сэкономим время. Это бьется с «инвестиционным подходом» из 3-й главы: потрать время сейчас, чтобы не ебаться потом.

С другой стороны (и мы все это знаем), предсказывать будущее в IT — дело неблагодарное. В итоге твое «универсальное решение» обрастет функционалом, который нахер никому не нужен. Более того, если сделать что-то *слишком* общим, оно будет хреново решать ту конкретную задачу, которая горит прямо сейчас. Поэтому адепты YAGNI («You Ain’t Gonna Need It») скажут: не выпендривайся, делай то, что нужно сегодня. А если потом припрет — отрефакторишь. Это такой инкрементальный подход: не плоди сущности без нужды.

## **6.1 Делай классы универсальными (General-purpose, а не one-off shit)**

Мой опыт подсказывает, что золотая середина — это модули, которые **«в меру универсальны»** (somewhat general-purpose).

Что это значит? Функционал модуля должен отражать твои текущие потребности (не надо писать космолет), но вот его **интерфейс** должен быть достаточно общим. Интерфейс должен быть таким, чтобы его можно было заюзать для разных целей, но при этом он должен быть удобным для твоего текущего таска.

Ключевое слово тут — **«в меру»**. Не надо упарываться и строить абстракцию ради абстракции, которой невозможно пользоваться без бутылки водки.

Самый жирный (и для многих внезапный) плюс такого подхода: универсальные интерфейсы получаются **проще и глубже**, чем специализированные костыли. Даже если ты никогда не заюзаешь этот модуль повторно, он все равно будет лучше просто потому, что он, сука, проще.

## **6.2 Пример: Хранение текста в редакторе**

Возьмем пример из универа. Студентам дали задачу: запилить простенький GUI текстовый редактор. Ну, знаете: открыть файл, потыкать мышкой, напечатать хуйню, сохранить. Нужно было поддержать несколько окон с одним файлом, многоуровневый undo/redo — короче, классика.

У всех проектов был класс, отвечающий за хранение текста. Загрузить, прочитать, изменить, сохранить.

Че сделали многие студенты? Они начали лепить **специализированный API** под конкретные кнопки интерфейса. Они знали, что делают редактор, и решили: «О, у нас есть кнопка Backspace и кнопка Delete, давайте сделаем под них методы!».

Например, Backspace удаляет символ слева от курсора, а Delete — справа. И гении мысли родили в текстовом классе такие методы:

```java
void backspace(Cursor cursor);

void delete(Cursor cursor);
```

Оба метода принимают позицию курсора. А еще была возможность выделить текст и удалить его, поэтому они добавили:

```java
void deleteSelection(Selection selection);
```

Студенты думали, что так будет проще пилить UI. Типа, нажал юзер кнопку — вызвали одноименный метод.

На деле же это **лютый самообстрел**. Такой подход дал ноль пользы для UI-кода, но создал дикую когнитивную нагрузку. Текстовый класс превратился в помойку из кучи мелких, поверхностных (shallow) методов. Каждый метод годился ровно для одной операции. Метод `delete` вызывался ровно в одном месте программы.

В итоге:
1. Разраб UI должен учить кучу методов текстового класса.
2. Произошла **утечка информации** (information leakage). Текстовый класс внезапно знает про какие-то «курсоры», «бэкспейсы» и «выделения».
3. UI и логика текста сплелись в клубок целующихся змей. Хочешь добавить новую фичу в интерфейс? Пиздуй переписывать класс текста.

## **6.3 Более общие интерфейсы**

А теперь как надо было сделать. Делаем класс текста более общим. Его API должен оперировать понятиями **текста**, а не кнопок в гуе.

Для изменения текста нам, по сути, нужны всего два метода:

```java
void insert(Position position, String newText);

void delete(Position start, Position end);
```

Всё.
Первый вставляет любую строку куда скажешь. Второй выпиливает всё нахер между `start` и `end`. И заметьте, мы используем общий тип `Position`, а не специфичный для UI `Cursor`.

Еще добавим утилиту для навигации:

```java
Position changePosition(Position position, int numChars);
```

Этот метод просто двигает позицию на N символов (в плюс или в минус), перескакивая строки если надо.

Теперь, как реализовать кнопку **Delete** (удаляем символ справа)?
```java
text.delete(cursor, text.changePosition(cursor, 1));
```

А как **Backspace** (удаляем символ слева)?
```java
text.delete(text.changePosition(cursor, -1), cursor);
```

Да, кода в UI стало чуть больше (целая строчка вместо вызова одного метода!). Но зато этот код **очевиден**.
Разраб, который пишет UI, видит: «Ага, мы удаляем от `cursor-1` до `cursor`. Понятно, это предыдущий символ».
В старом варианте ему пришлось бы лезть в документацию или код метода `backspace()`, чтобы убедиться, что он делает именно то, что нужно, и не форматирует диск C.

И главное: сам класс текста стал чище. Вместо зоопарка методов (`backspace`, `delete`, `deleteSelection`, `deleteMyHope`) у нас один универсальный `delete`.

Бонус: такой класс текста можно заюзать где угодно. Например, если ты пишешь тулзу для автозамены слов в файлах. Методы `backspace` там нахер не нужны, а вот `insert`, `delete` и какой-нибудь `findNext` — это база.

## **6.4 Обобщение помогает лучше прятать кишки**

Универсальный подход четко разделяет ответственность. Текстовому классу насрать, как работает Backspace. Это проблемы UI.
Если ты захочешь поменять поведение интерфейса, тебе не надо трогать кишки текстового движка.

Старый метод `backspace` в текстовом классе был **фейковой абстракцией** (false abstraction). Он делал вид, что скрывает сложность, но на самом деле просто прятал важные детали (какие именно символы удаляются), которые UI-разрабу *нужно* знать. Скрывать такую инфу — это не инкапсуляция, это создание мути (obscurity).

## **6.5 Вопросы к самому себе (Ты точно не идиот?)**

Сделать хороший универсальный интерфейс сложнее, чем накостылять специализированный. Вот вопросы, которые помогут тебе не написать говно:

1.  **Какой самый простой интерфейс покроет ВСЕ мои текущие нужды?**
    Если ты можешь заменить три метода одним (как `delete` заменил собой `backspace`, `delete` и `deleteSelection`), и при этом не нужно передавать в него 100500 параметров — ты на верном пути.

2.  **В скольких ситуациях этот метод будет юзаться?**
    Если метод нужен только для одного конкретного кейса (как `backspace`) — это **красный флаг**. Это костыль. Попробуй заменить его на что-то более общее.

3.  **Удобно ли это юзать прямо сейчас?**
    Тут важно не перегнуть. Можно сделать класс текста, который умеет вставлять и удалять *только по одному символу*. Это пиздец как универсально и просто. Но писать код на таком API — это боль и куча циклов. Это уже перебор. API должен поддерживать операции над диапазонами (строками), чтобы не быть бесполезным куском кода.

## **6.6 Итог**

Универсальные интерфейсы ебут специализированные.
Они проще. У них меньше методов, но эти методы глубже. Они обеспечивают чистую архитектуру и не дают классам протекать друг в друга.
Делай свои модули «в меру универсальными» — это один из лучших способов не дать сложности сожрать твой проект.