# **ГЛАВА 5. ПРЯЧЕМ ИНФУ (И ПРОЁБЫВАЕМ ЕЁ)**

В прошлой главе мы выяснили, что модули должны быть глубокими. В этой (и следующих) главах мы разберем техники, как сделать так, чтобы твой код был действительно глубоким, а не просто запутанным куском... ну ты понял.

## **5.1 Сокрытие информации (Шифруемся грамотно)**

Самая главная техника для создания глубоких модулей — это **сокрытие информации**. Эту фишку придумал Дэвид Парнас ещё в лохматые 70-е. Базовая идея проста: каждый модуль должен инкапсулировать (читай: прятать внутри себя) кусок знаний о том, как всё устроено. Эти знания живут внутри реализации, но в интерфейсе их не видно. Другим модулям вообще не всралось знать, что у тебя там под капотом.

Обычно прячут детали реализации механизмов. Примеры того, что нормальные люди прячут внутри модуля:

*   Как хранить данные в B-дереве и искать их там, не умирая от старости.
*   Как мапить логические блоки файла на физические сектора диска (тебе оно надо?).
*   Как на самом деле работает протокол TCP (поверь, ты не хочешь этого знать).
*   Как шедулить потоки на многоядерном проце.
*   Как парсить этот сраный JSON.

---

Скрытая инфа — это структуры данных и алгоритмы. Это могут быть низкоуровневые детали (типа размера страницы памяти) или высокоуровневые абстракции (типа предположения, что "большинство файлов маленькие, так что похер").

Сокрытие информации снижает сложность двумя путями:

1.  **Упрощает интерфейс.** Интерфейс становится чище и абстрактнее. Это снижает когнитивную нагрузку на разраба. Если ты юзаешь класс B-дерева, тебе насрать на балансировку узлов. Ты просто говоришь: "Найди мне X", и оно находит.
2.  **Упрощает эволюцию системы.** Если ты спрятал кишки модуля внутри, то снаружи от них никто не зависит. Захотел поменять реализацию TCP? Меняй. Верхнеуровневый код, который просто шлет байтики, даже не чихнет.

**Совет:** Когда дизайнишь новый модуль, крепко подумай, какую инфу можно заныкать. Чем больше ты спрячешь, тем проще будет интерфейс, и тем глубже будет модуль.

**Важное примечание:** Объявить переменные и методы `private` — это еще не сокрытие информации. Если ты сделал переменную приватной, но налепил к ней публичные геттеры и сеттеры, то ты, по сути, просто выставил её напоказ. Ты ничего не спрятал, ты просто добавил бюрократии.

Лучшая форма сокрытия — когда инфа вообще не видна снаружи. Но частичное сокрытие тоже катит. Если какая-то фича нужна только паре фриков, спрячь её за отдельными методами, чтобы нормальные люди не спотыкались об неё в основных сценариях.

## **5.2 Утечка информации (Когда всё протекло)**

Противоположность сокрытия — **утечка информации**. Это когда твое "гениальное" архитектурное решение размазано по нескольким модулям. Это создает зависимость: поменял что-то в одном месте — иди правь в пяти других.

Если деталь реализации торчит в интерфейсе — это официальная утечка. Но бывает и хуже: **скрытая утечка**. Представь два класса, которые оба знают про формат какого-то файла. Даже если они не светят это в интерфейсе, они оба зависят от этого формата. Поменял формат — переписывай оба класса. Такая утечка через задний проход (back-door leakage) — самая подлая херня, потому что её не видно сразу.

Утечка информации — это жирнющий красный флаг. Хороший дизайнер чует утечку за версту. Видишь утечку? Спроси себя: "Как мне перетасовать классы так, чтобы это знание жило только в одном месте?". Иногда проще слить два мелких класса в один большой, чем трахаться с зависимостями. Или вынести эту инфу в третий, новый класс. Но только если у него будет простой интерфейс, иначе ты просто переложил говно из одной кучи в другую.

> **АХТУНГ: Утечка информации**
> Утечка происходит, когда одно и то же знание используется в разных местах. Например, два разных класса знают структуру одного файла. Поменяешь файл — сломаешь оба класса.

## **5.3 Временная декомпозиция (Любимая ошибка новичков)**

Частая причина утечек — стиль дизайна, который я называю **временнóй декомпозицией**. Это когда ты структурируешь систему по порядку действий во времени.

Типа: "Сначала мы читаем файл, потом меняем данные, потом пишем файл".
И ты, недолго думая, пилишь три класса: `FileReader`, `DataModifier`, `FileWriter`.
В итоге и читатель, и писатель знают про формат файла. Поздравляю, у тебя утечка.

Решение: запихни чтение и запись в один класс, который шарит за формат файла.
В ловушку временной декомпозиции легко попасть, потому что ты, когда кодишь, думаешь алгоритмом: "сначала это, потом то". Но архитектура должна строиться вокруг **знаний**, а не вокруг **порядка действий**.

> **АХТУНГ: Временная декомпозиция**
> Это когда структура кода повторяет порядок выполнения. Операции, которые происходят в разное время, разлетаются по разным классам. Если одно знание нужно на разных этапах, оно дублируется, и мы получаем утечку.

## **5.4 Пример: HTTP сервер**

Давайте посмотрим на студентов, которые писали HTTP-сервер. На их ошибках учиться веселее.

HTTP — это протокол, по которому браузер базарит с сервером. Запрос — это текст. Студентам надо было написать классы для приема запросов и отправки ответов.

*(Тут была картинка с HTTP запросом, но ты и так знаешь, как выглядит POST-запрос, не маленький).*

## **5.5 Пример: слишком много классов**

Главный косяк студентов — они наплодили кучу мелких, плоских классов.
Одна команда сделала два класса для приема запроса: первый вычитывает байты из сокета в строку, второй парсит эту строку.
Это классическая **временная декомпозиция**: "сначала читаем, потом парсим".
Проблема в том, что ты не можешь нормально прочитать запрос, не распарсив его (тебе надо знать `Content-Length`, чтобы понять, сколько читать). В итоге оба класса должны знать структуру HTTP. Код дублируется, сложность растет, вызывающий код должен дергать два метода в строгом порядке. Бред.

Было бы лучше слить их в один класс. Это улучшает сокрытие информации (все знания о формате HTTP в одном месте) и упрощает жизнь (вызвал один метод и забыл).

Этот пример иллюстрирует важную мысль: **иногда жирный класс — это хорошо**.
Объединение кода в одном месте позволяет спрятать кишки и дать наружу простой интерфейс.

Конечно, не надо делать `GodObject`, который делает вообще всё. Но об этом в 9-й главе.

## **5.6 Пример: обработка параметров HTTP**

Серверу нужно достать параметры из запроса (типа `photo_id` или `comment`). Они могут быть в URL, могут быть в теле, и они еще закодированы (всякие `%20` вместо пробелов).

Что студенты сделали хорошо:
1.  Спрятали разницу между параметрами в URL и в теле. Вызывающему пофиг, где был параметр.
2.  Спрятали URL-декодирование. Сервер отдает уже нормальный текст "Hello World", а не "Hello%20World".

Где они облажались:
Почти все сделали метод типа такого:

```java
public Map<String, String> getParams() {
    return this.params;
}
```

Это, блядь, фиаско. Метод возвращает ссылку на внутреннюю `Map`.
1.  Это **плоский интерфейс**. Ты вываливаешь свои кишки (внутреннюю структуру данных) наружу. Захочешь поменять `Map` на что-то другое — переписывай весь проект.
2.  Это неудобно. Юзеру надо вызвать `getParams()`, получить карту, потом дергать карту.
3.  Это опасно. Юзер может случайно (или специально) поменять эту карту и сломать состояние объекта `HTTPRequest`.

Нормальный пацанский интерфейс выглядит так:

```java
public String getParameter(String name) { ... }
public int getIntParameter(String name) { ... }
```

`getParameter` прячет структуру хранения.
`getIntParameter` сразу парсит строку в число. Это удобно: не надо самому делать `Integer.parseInt` и ловить эксепшены каждый раз.
Это пример **глубокого интерфейса**.

## **5.7 Пример: дефолты в HTTP ответах**

Еще одна боль — создание ответов.
Студенты заставляли юзера указывать версию HTTP при создании ответа.
Алло! Версия ответа должна совпадать с версией запроса. Библиотека сама знает запрос, пусть сама и подставит версию. Юзер вообще может не знать, какая там версия.
То же самое с датой (`Date` header). Библиотека должна ставить текущее время по дефолту.

**Дефолты** — это круто. Они делают интерфейс простым для 99% случаев. Если кому-то реально надо переопределить дату — дай ему отдельный метод. Но по умолчанию всё должно работать "из коробки".

Хороший класс должен делать правильные вещи, не заставляя тебя умолять об этом.
Плохой пример — Java I/O. Чтобы получить буферизацию (которая нужна всем и всегда), ты должен явно обернуть стрим в `BufferedInputStream`. Какого хера? Оно должно быть включено по дефолту! Лучшие фичи — это те, о существовании которых ты даже не догадываешься, потому что они просто работают.

> **АХТУНГ: Эксгибиционизм в API**
> Если для простой задачи API заставляет меня изучать настройки, которые нужны раз в сто лет — это плохой дизайн. Это грузит мозг.

## **5.8 Сокрытие информации внутри класса**

Сокрытие работает не только для публичных API. Внутри класса тоже надо прятать говно.
Дизайни приватные методы и переменные так, чтобы минимизировать доступ к ним.
Если переменная используется во всем классе — это повод напрячься. Если можно ограничить её использование парой методов — сделай это. Чем меньше мест, где трогают данные, тем меньше шансов, что какой-то джун их запорет.

## **5.9 Не перегибай палку**

Сокрытие имеет смысл, только если инфа не нужна снаружи.
Если параметр реально нужен юзеру для настройки производительности — **не прячь его**. Выставь его в интерфейс.
Твоя цель — минимизировать инфу, которая *нужна* снаружи, а не скрывать то, без чего работать невозможно. Если модуль может настроиться сам — круто. Если нет — дай ручку настройки, не будь мудаком.

## **5.10 Итог**

Сокрытие информации и глубокие модули — это братья навек.
Чем больше ты прячешь, тем глубже модуль.
Чем больше ты вываливаешь наружу, тем он более плоский и убогий.

Когда нарезаешь систему на модули:
1.  Забей на порядок действий во времени (это путь к временной декомпозиции и страданиям).
2.  Думай о **знаниях**.
3.  Инкапсулируй каждое знание в отдельный модуль.

Так победишь.