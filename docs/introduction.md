# **1. Введение: Вход в кроличью нору**

Написание софта — это, пожалуй, одно из самых чистых проявлений творчества в истории человечества. Программисты не скованы скучными законами физики; мы можем создавать виртуальные миры с таким поведением, которое в реальности и не снилось. Это тебе не балет и не баскетбол, тут не нужна физуха или координация. Тут нужен креативный мозг и умение структурировать свои мысли. Если ты можешь представить какую-то дичь, ты, скорее всего, сможешь её закодить.

А это значит, что единственное ограничение — это наша собственная способность понять то, что мы сами же и наворотили. По мере того как программа эволюционирует и обрастает фичами, она становится, сука, сложной из-за хитрых зависимостей между компонентами. Сложность копится как снежный ком, и со временем программисту становится всё труднее удерживать в голове все нюансы, чтобы внести правки и не развалить всё к чертям. Это тормозит разработку, плодит баги, которые снова тормозят разработку и раздувают бюджет. Рост сложности неизбежен, как смерть и налоги. И чем больше проект и толпа людей, которые в нём ковыряются, тем сложнее не дать этому хаосу победить.

Хорошие инструменты помогают бороться с этим пиздецом, и за последние десятилетия их придумали немало. Но тулзы — это не панацея. Если мы хотим, чтобы писать софт было проще (и чтобы мы могли пилить крутые системы дешевле), нам нужно найти способы упрощения самого кода. Как бы мы ни старались, сложность будет расти, но грамотный дизайн позволит нам построить огромную, мощную систему до того, как она схлопнется под собственным весом.

Есть два основных способа нагнуть сложность, и оба мы разберем в этой книге. Первый — сделать код проще и очевиднее. Например, выкинуть нахер «особые случаи» (special cases) или использовать единообразные подходы.

Второй способ — инкапсуляция, или «спрячь говно в коробку». Это модульный дизайн. Ты пилишь систему на модули (например, классы в ООП), и они должны быть максимально независимы. Чтобы ты мог ковыряться в одном модуле и тебе было абсолютно насрать, что там происходит внутри другого.

Поскольку софт пластичен, как пластилин, его дизайн — это непрерывный процесс, который длится, пока код не сгниет окончательно. Этим мы отличаемся от строителей мостов или кораблей. Но, к сожалению, про дизайн часто забывают. Раньше вообще было модно использовать «Водопад» (Waterfall): типа сначала умные дядьки всё спроектируют, а потом макаки накодят. Дизайн замораживали в начале, а дальше — только реализация.

Спойлер: Водопад для разработки софта подходит чуть менее, чем никак. Софт сложнее мостов. Ты не можешь в начале проекта предусмотреть все факапы. Проблемы вылезают, только когда ты начинаешь кодить. Но в Водопаде менять дизайн уже поздно (архитектор уже ушел в запой или на другой проект). В итоге разрабы начинают лепить костыли, не меняя общей структуры. Результат — взрывной рост сложности и желание уволиться.

Из-за этого сейчас все сидят на «Инкрементальных» методах (типа Agile). Дизайним и кодим по чуть-чуть. Сделали кусок, посмотрели, охуели, исправили. Каждый шаг вскрывает проблемы текущего дизайна, и их чинят перед тем, как пилить дальше.

Так можно выловить косяки, пока система еще маленькая. Поздние фичи встают на нормальный фундамент, а не на кучу костылей.

Инкрементальный подход работает, потому что софт можно менять. Попробуй-ка переставить опоры моста, когда он уже наполовину построен. Удачи.

Но это также значит, что дизайн софта **никогда не заканчивается**. Ты постоянно должен думать о дизайне. И постоянно переделывать то, что уже есть. Первое решение почти всегда — говно, практика показывает, как надо было делать на самом деле. Как разработчик, ты всегда должен искать шанс улучшить дизайн и закладывать на это время.

Если разработчик должен постоянно думать о дизайне, а суть дизайна — борьба со сложностью, то, блядь, разработчик должен постоянно думать о сложности. Эта книга о том, как использовать эту идею как путеводную звезду, чтобы не утонуть в говнокоде.

У книги две цели. Первая — объяснить природу сложности: что это за зверь, почему это важно и как понять, что ваш код стал неоправданно сложным куском... кхм. Вторая, более сложная цель — показать методы борьбы с этим злом. К сожалению, волшебной таблетки нет. Я предложу скорее философские принципы высокого уровня, типа «классы должны быть глубокими» или «дизайн так, чтобы ошибок не существовало». Это не готовые рецепты, а инструменты для размышления и выбора меньшего из зол.

## 1.1 Как юзать эту книгу (Инструкция)

Многие принципы здесь абстрактны, и без реального кода их хрен поймешь. Впихнуть в книгу примеры из реальных огромных систем сложно — они тупо не влезут. Поэтому одной книги может быть мало.

Лучший способ просветлиться — читать эту книгу и идти на **Code Review**. Когда читаешь чужой код, думай: соответствует ли он этим принципам? Не усложнил ли автор жизнь себе и другим? В чужом коде увидеть говно всегда проще, чем в своем. Ищите «Красные флаги» (Red Flags), о которых я буду говорить, и предлагайте, как сделать лучше.

Один из лучших навыков — научиться видеть эти «Красные флаги»: сигналы того, что код сложнее, чем должен быть. Я буду тыкать в них носом всю книгу, а в конце будет шпаргалка. Увидел флаг — остановись и переделай. Сначала придется перебирать варианты, чтобы найти нормальный. Не ссыте: чем больше вариантов переберете, тем быстрее прокачаетесь. Со временем ваш код станет чище, а флагов станет меньше.

Но важно: **без фанатизма**. У каждого правила есть исключения. Если доводить любую идею до абсурда, вы загоните себя в угол. В некоторых главах есть раздел «Когда ты зашел слишком далеко» — читайте внимательно.

Примеры в книге на Java и C++, и много базара про классы. Но эти идеи работают везде. Хоть на Си пиши, хоть на микросервисах.

А теперь давайте разберемся, откуда берется эта сраная сложность и как нам с ней жить.