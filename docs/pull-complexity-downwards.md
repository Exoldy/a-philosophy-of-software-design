# **Глава 8. Утаскивай сложность на дно**

### **(Или «Страдай сам, чтобы другим было по кайфу»)**

В этой главе мы поговорим о еще одном способе делать классы «глубокими», а не поверхностными пустышками. Допустим, ты пилишь новый модуль и наткнулся на кусок неизбежной, лютой ебанины (сложности). Возникает вопрос: вывалить эту сложность на тех, кто будет юзать твой модуль, или молча разгрести это дерьмо внутри?

Если эта сложность хоть как-то касается функционала твоего модуля, то правильный ответ почти всегда второй. У большинства модулей пользователей (других разрабов) больше, чем авторов. Поэтому, с точки зрения гуманизма и здравого смысла, **лучше пусть пострадает один разраб (ты), чем будут вечно мучиться все пользователи твоего кода**.

Твоя задача как создателя модуля — сделать жизнь юзера максимально сладкой, даже если ради этого тебе придется попотеть и написать пару лишних сотен строк. Перефразируя: **простой интерфейс важнее простой реализации**.

Но мы же знаем, как работают программисты. Соблазн сделать наоборот велик: решить простые задачки, а сложные — спихнуть на соседа.
*   Не знаешь, как обработать ситуацию? Кидай `Exception`, пусть вызывающий код ебётся.
*   Не уверен, какую политику выбрать? Заведи пару параметров в конфиге, пусть сисадмин гадает, какие значения туда вписать.

Такой подход облегчит твою жизнь здесь и сейчас, но в долгосроке это увеличивает энтропию и пиздец во всей системе. Вместо того чтобы проблему решил один человек (ты), с ней теперь будет трахаться каждый, кто вызовет твой метод. Если класс плюется исключениями, каждый вызов превращается в `try-catch` ад. Если класс требует настройки, каждый админ на каждой инсталляции будет гуглить мануалы.

---

## **8.1 Пример: Класс для текста в редакторе**

Вспомним тот класс для текстового редактора из глав 6 и 7. Он должен читать файл, держать его в памяти и сохранять обратно.

Когда студентам (читай: джунам) давали это задание, многие выбирали **построчный интерфейс**. Типа методы `readLine`, `insertLine`, `deleteLine`.
Почему? Потому что реализовать такую шнягу проще пареной репы.

Но для того, кто пишет UI поверх этого класса, это **полный ад**.
В интерфейсе операции редко касаются целых строк. Юзер нажал клавишу — надо вставить символ в середину строки. Юзер выделил текст и нажал Delete — это может затронуть куски трех разных строк.
С «простым» построчным интерфейсом высокоуровневый код вынужден постоянно резать строки, склеивать их обратно и заниматься прочей акробатикой.

А вот **посимвольный интерфейс** (как в разделе 6.3) — это пример того, как сложность утаскивается вниз. UI-код просто говорит: «удали текст с позиции А по позицию Б», и ему похер на строки. Жить стало проще.
Да, реализация самого текстового класса стала сложнее: если внутри всё хранится как массив строк, тебе придется самому их резать и клеить. Но это **правильный подход**. Ты инкапсулируешь (прячешь) этот геморрой внутри класса, снижая общую сложность системы. Говно не плавает на поверхности, оно надежно спрятано в трубах.

---

## **8.2 Пример: Параметры конфигурации**

Конфиги — это классический пример того, как сложность всплывает наверх, вместо того чтобы тонуть. Вместо того чтобы решить, как системе работать, класс говорит: «Я хз, вот вам параметры `cache_size` и `retry_count`, сами разбирайтесь».
Сейчас модно делать системы с сотнями параметров.

Адепты этого подхода кукарекают, что это круто: мол, юзеры могут «тюнить» систему под себя. Иногда это правда — низкоуровневый код не может знать всё о контексте.
Но будем честны: чаще всего конфиги — это просто **отмазка**, чтобы не решать сложные вопросы.

В большинстве случаев юзеры (и даже админы) в душе не ебут, какие значения там выставлять.
Часто правильные значения можно вычислить автоматически, если не лениться.

Возьмем сетевой протокол. Пакеты теряются, надо делать повторную отправку (retry). Сколько ждать перед повтором?
*   **Ленивый путь:** Сделать параметр `retry_interval` в конфиге. Пусть юзер гадает.
*   **Нормальный путь:** Протокол сам замеряет время ответа успешных запросов и на основе этого динамически вычисляет таймаут.

Второй подход утаскивает сложность вниз. Юзеру не надо думать. Более того, система адаптируется сама, если сеть начнет тупить. А жестко забитый конфиг устареет и станет бесполезным куском говна.

**Совет:** Избегай конфигурационных параметров как чумы. Перед тем как добавить новый, спроси себя: «А юзер реально сможет определить это значение лучше, чем мой код?». Если уж приходится делать конфиг — сделай так, чтобы дефолтные значения работали в 99% случаев, и юзер лез туда только в случае ядерной войны.
Идеальный модуль решает проблему целиком. Конфиги — это признак недоделанного решения.

---

## **8.3 Без фанатизма**

Утаскивать сложность вниз надо с умом. Если перегнуть палку, можно получить «Божественный Объект» (God Class), который делает вообще всё. Это тоже дичь.

Спускать сложность имеет смысл, если:
а) Эта сложность тесно связана с функционалом класса.
б) Это упростит жизнь всем остальным частям программы.
в) Интерфейс класса станет чище.

В главе 6 был пример, где студенты пихали в текстовый класс логику кнопки Backspace. Казалось бы — утащили сложность вниз? Нет, нихуя.
Знание о том, как работает Backspace — это уровень UI. Пихая это в класс хранения данных, ты не упрощаешь систему, а смешиваешь слои ответственности. Это называется **утечка информации** (information leakage), и это плохо. Не надо путать «спрятать сложность реализации» и «свалить всё в одну кучу».

---

## **8.4 Итог**

Когда пишешь модуль, ищи возможность взять на себя чуть больше страданий, чтобы твоим пользователям жилось чуть легче. Будь мужиком, разгреби сложность сам.