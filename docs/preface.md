# **Предисловие: На кой хрен я это написал**

Человечество долбит по клавишам и пишет код уже больше 80 лет, но вот что удивительно: мы до сих пор нихера не говорим о том, как *дизайнить* программы или как вообще выглядит «хороший код». Зато про всякие процессы разработки (типа вашего любимого Agile) и тулзы (дебаггеры, гит, инструменты для дрочки на покрытие тестами) написано столько, что можно топить печи. Техники программирования (ООП, функциональщина), паттерны и алгоритмы тоже обсосали со всех сторон. Это всё, конечно, полезно, но проблему дизайна софта это решает примерно никак. Классическая статья Дэвида Парнаса о том, как вообще разбивать систему на модули, вышла в далеком 1971 году, и, сука, за 45 лет мы не то чтобы сильно далеко ушли от этой точки.

Самая базовая проблема в Computer Science — это декомпозиция: как взять одну здоровенную, сложную ебанину и распилить её на мелкие кусочки, которые можно решать по отдельности. Этим программисты занимаются каждый божий день, но я ни в одном универе не видел курса, где бы учили именно *этому*. Мы учим студентов крутить циклы и создавать классы в ООП, но не учим их *строить* системы.

Кроме того, разрыв в продуктивности и качестве между крутыми разрабами и середнячками просто космический. Но мы почти не пытаемся понять, *почему* эти «рок-звезды» такие крутые, и как этому научить остальных. Я общался с кучей топовых программистов, и знаете что? Большинство из них двух слов связать не могут, чтобы объяснить, *как* они это делают. Многие вообще считают, что умение дизайнить софт — это врожденный дар, типа магии, и научить этому нельзя. Хотя наука говорит об обратном: выдающиеся результаты — это чаще всего результат задротства и правильной практики, а не какого-то там «таланта» (почитайте Джеффа Колвина, «Talent is Overrated», если не верите).

Меня эта херня бесила годами. Я хотел понять, можно ли научить дизайну, и исходил из гипотезы, что именно скилл дизайна отличает сеньора-помидора от обычного кодера. В итоге я понял: единственный способ проверить — запилить свой курс. Так появился CS 190 в Стэнфорде. Там я выкатил набор принципов дизайна. Студенты херачат проекты, чтобы эти принципы понять. Это похоже на уроки английского: пишешь черновик, получаешь люлей (фидбек), переписываешь. В CS 190 студенты с нуля пилят реальный софт. Потом мы устраиваем тотальное код-ревью, находим, где дизайн свернул не туда, и студенты переписывают код, чтобы исправить это говно. Так они на практике видят, как принципы делают код лучше.

Я уже несколько раз читал этот курс, и книга основана именно на том, что мы там разбирали. Принципы тут довольно высокоуровневые, почти философские (типа «определяй ошибки, которых не существует» — звучит как дзен-буддизм, да?), поэтому студентам сложно въехать в абстракцию. Лучший способ научиться — это написать код, жёстко накосячить, понять, *почему* ты накосячил, и исправить, используя принципы.

Вы сейчас, наверное, думаете: «С хера ли этот чувак решил, что он знает всё про дизайн софта?». Честно? Я не знаю. Когда я учился, курсов по дизайну не было, менторов у меня тоже не было. Код-ревью тогда вообще не существовало как класса. Всё, что я знаю, я узнал, читая чужой код и набивая шишки в своём. За карьеру я написал где-то 250 000 строк кода на разных языках. Я работал в куче команд, с нуля запилил три операционки, файловые системы, тулзы (дебаггеры, системы сборки, GUI-тулкиты), скриптовый язык и всякие редакторы. Я лично хлебнул горя с проблемами огромных систем и перепробовал кучу подходов. Плюс я прочитал тонны чужого говнокода (и хорошего кода тоже), так что насмотренность у меня есть.

Из всего этого опыта я попытался выжать суть: как не наступать на грабли и какие трюки работают. Эта книга — тупо моя практика. Каждая проблема, описанная здесь, — это то, с чем я лично ебался, и каждое решение — это то, что реально сработало в моем коде.

Я не претендую на то, что эта книга — истина в последней инстанции. Я стопудово упустил какие-то крутые техники, а какие-то мои советы со временем могут оказаться полным отстоем. Но я надеюсь, что эта книга хотя бы начнет *дискуссию* о дизайне. Сравнивайте то, что я пишу, со своим опытом. Думайте своей головой: реально ли это снижает сложность? Книга — это сборник мнений, так что вы имеете полное право не соглашаться. Если не согласны — попытайтесь понять почему. Мне интересно знать, что у вас работает, а что нет. Надеюсь, срачи в комментах поднимут общий уровень индустрии. Всё полезное я добавлю в следующие версии книги. Лучший способ достучаться до меня — мыло:

[software-design-book@googlegroups.com](mailto:software-design-book@googlegroups.com)

Мне интересен конкретный фидбек: ошибки, предложения, или просто мысли за жизнь о дизайне софта. Особенно буду рад крутым примерам кода (как хорошего, так и ужасного) для будущих изданий. Хороший пример — это тот, который иллюстрирует принцип и который можно объяснить за пару абзацев, не взрывая мозг. Хотите участвовать в срачах — велкам в гугл-группу `software-design-book`.

Если гугл вдруг решит убить группы (а они могут), ищите меня через мой сайт. Только, пожалуйста, не засрите мою личную почту, пишите куда сказано.

И последний совет: читайте эту книгу со здоровым скепсисом. Наша цель — снизить сложность. Это важнее, чем любой конкретный принцип, описанный здесь. Если вы пробуете что-то из книги, и видите, что код становится только запутаннее — выкидывайте этот совет нахер (но напишите мне об этом, мне интересно).

Книга стала лучше благодаря людям, которые не побоялись её покритиковать. Спасибо этим ребятам за фидбек к черновикам: Джефф Дин, Санджай Гемават и вся остальная банда (список имен). Отдельное спасибо Кристосу Козиракису, который предложил использовать термины «глубокий» и «мелкий» (deep/shallow) для классов вместо «толстый» и «тонкий», которые звучали как-то двусмысленно. И огромный респект студентам CS 190 — чтение вашего кода и разбор полетов помогли мне структурировать тот хаос, что был у меня в голове.