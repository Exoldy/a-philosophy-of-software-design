# **10. Ошибок не существует (Define Errors Out of Existence)**

Обработка исключений — это один из самых жирных источников сложности в софте. Код, который разгребает дерьмо (особые условия), писать сложнее, чем код, который просто делает работу. Разработчики часто объявляют исключения, вообще не отдупляя, как их потом будут обрабатывать. Эта глава пояснит, почему исключения — это зло, и покажет, как сделать так, чтобы их было поменьше.

**Спойлер:** Главная мысль главы — сократи количество мест, где нужно подтирать за кодом. В идеале — измени семантику операций так, чтобы "ошибок" тупо не существовало.

## **10.1 Почему Exception увеличивает сложность (Потому что ты их не обрабатываешь)**

Под "исключением" я понимаю любую херню, которая прерывает нормальный поток выполнения программы. Это может быть `throw` в языке, а может быть спец-значение (типа вернуть `-1`, когда ждали позитив). И то, и другое — боль.

Откуда прилетает этот нежданчик:
*   Вызывающий код передал кривые аргументы (руки из жопы).
*   Метод не смог сделать работу (I/O сдох, ресурса нет).
*   В распределенной системе пакеты потерялись или сервер ушел в запой.
*   Код нашел баг или несогласованность внутри себя.

Код обработки ошибок писать сложнее, чем обычный. Исключение ломает флоу. У тебя два пути, и оба хреновые:
1.  **Попытаться починить и продолжить.** (Типа переслать пакет). Но это может привести к дублям или бесконечным циклам ада.
2.  **Бросить всё и умереть (abort).** Но тогда надо откатывать состояние системы, иначе оставишь после себя битые структуры данных.

Более того, код обработки ошибок часто **сам генерирует новые ошибки**. Пытался восстановить данные из бэкапа? А бэкап тоже битый. Поздравляю, ты в рекурсивной жопе.

Языковая поддержка исключений (особенно в Java) — это отдельный вид пытки. Взгляните на этот кусок кода для чтения твитов:
```java
try {
    // Три строчки полезного кода
} catch (FileNotFoundException e) { ... }
catch (ClassNotFoundException e) { ... }
catch (IOException e) { ... }
catch (ClassCastException e) { ... }
```
Бойлерплейта больше, чем логики. Читать это невозможно.

А самое веселое: **код обработки ошибок почти невозможно протестировать**. Эти ситуации на проде случаются раз в год, поэтому код хендлеров никогда не исполняется. А как гласит народная мудрость: "Код, который не запускался — не работает". 90% катастрофических падений распределенных систем случаются из-за кривой обработки ошибок.

## **10.2 Слишком дохера исключений**

Программисты сами роют себе могилу, создавая лишние исключения. Нас учат: "Отлавливай ошибки! Будь бдителен!". И начинается защитное программирование головного мозга: чуть что не так — кидаем эксепшн.

Я сам так обосрался, когда делал язык **Tcl**. Команда `unset` (удалить переменную) кидала ошибку, если переменной не существовало. Я думал: "Ну это же баг, если удаляют то, чего нет!".
А на практике `unset` часто используют для очистки мусора. И программистам приходилось оборачивать удаление в `catch`, чтобы скрипт не падал.
Это была одна из моих самых тупых ошибок в дизайне.

Исключение — это часть интерфейса. Класс, который плюется ошибками на каждый чих — сложный и ненадежный.

## **10.3 Спроектируй так, чтобы ошибки не возникали**

Лучший способ не обрабатывать исключения — сделать так, чтобы их не было.
Вернемся к моему факапу с `unset`. Надо было просто изменить определение: `unset` не "удаляет переменную", а "обеспечивает, чтобы переменной не было".
Если переменной и так нет — задача выполнена. Успех. Ошибки не существует. Профит.

## **10.4 Пример: Удаление файла в Windows (Ад) vs Unix (Рай)**

**Windows:** Если файл открыт процессом, хер ты его удалишь. Это бесконечный источник боли. Юзеру надо искать, какой процесс держит файл, убивать его, или ребутать комп.
**Unix:** Если файл открыт, Unix помечает его "на удаление" и возвращает успех. Имя файла исчезает из папки (новые процессы его не найдут), но старые процессы спокойно дочитывают данные. Когда все закроют файл — он исчезнет физически.

Unix просто взял и определил две ошибки как "не ошибки":
1. Удаление занятого файла — теперь ОК.
2. Чтение удаленного файла текущими процессами — теперь ОК.

В итоге: меньше геморроя, меньше кода, все счастливы.

## **10.5 Пример: Java substring (Как выстрелить себе в ногу)**

Метод `substring` в Java — это истеричка. Если ты попросишь подстроку, выходящую за границы, он кинет `IndexOutOfBoundsException`.
Зачем? Мне часто нужно просто "дай мне всё, что есть в этом диапазоне". Приходится писать 10 строк проверок индексов.
Нормальный API (как срезы в Python) просто возвращает пересечение запрошенного диапазона и строки. Если индексы за пределами — верни пустую строку или то, что влезло. Ошибки нет, код чище.

Аргумент "а вдруг это баг, надо сообщить!" — слабый. Выкидывание исключений увеличивает сложность, а сложность порождает еще больше багов.

## **10.6 Маскировка исключений (Типа ничего не случилось)**

Второй метод: решай проблемы на низком уровне, чтобы "начальство" (верхний уровень кода) не знало.

*   **TCP:** Если пакет потерялся, протокол сам его перепошлет. Приложению вообще пофиг, оно думает, что сеть идеальна.
*   **NFS (Сетевая файловая система):** Если сервер завис, клиент NFS просто... виснет. Он будет долбиться в сервер до посинения.
    Юзеры ноют, что приложение "зависло". Но альтернатива — выкинуть ошибку. И что приложение будет с ней делать? Скорее всего, упадет. А так, сервер очнется, и всё продолжит работать, как ни в чем не бывало.

Это пример "спускания сложности вниз". Класс становится глубже, интерфейс проще.

## **10.7 Агрегация исключений**

Третий метод: обрабатывай кучу разных ошибок в одном месте.

Представьте веб-сервер. У него куча обработчиков URL. Каждый достает параметры. Если параметра нет — ошибка.
**Плохой путь:** В каждом методе свой `try-catch`. Куча дубликатов.
**Хороший путь:** Пусть исключение летит на самый верх. Там, в главном цикле диспетчера, стоит один глобальный `try-catch`, который ловит всё и отдает клиенту красивый HTTP 400/500.

Пример из **RAMCloud**:
У них есть сложный механизм восстановления после падения сервера (восстанавливают данные с других нод).
А что делать, если найден *один* битый объект?
Они решили не писать отдельный код для восстановления одного объекта. Они просто **крашат сервер**, на котором нашли битый объект.
Звучит дико? Да. Но это позволяет использовать *уже написанный и отлаженный* механизм восстановления сервера.
Мы превращаем мелкую ошибку в крупную, чтобы обработать её общим механизмом.

## **10.8 А может, просто крашнуться? (Иногда лучше сдохнуть сразу)**

Четвертый метод: **Abort.**
Некоторые ошибки не стоит пытаться обрабатывать.
Пример: `malloc` в C возвращает `NULL`, если память кончилась. Это заставляет проверять каждый чих.
Если у тебя в 2024 году кончилась память — твоему приложению пизда. Не надо пытаться выжить, освобождая кэши. Скорее всего, это баг.
Просто напиши обертку `ckalloc`, которая при неудаче пишет в лог "Всё пропало" и убивает процесс.

То же самое с "невозможными" состояниями (internal inconsistency). Если структура данных сломана — это баг. Не лови его, пусть падает. Это честнее и безопаснее, чем работать с битыми данными.

## **10.9 Убираем "особые случаи" (Special cases)**

Спец-кейсы порождают `if`-ы. `If`-ы порождают баги.
Пример: Текстовый редактор.
Студенты часто делают переменную "выделение", которая может быть `null`, если ничего не выделено.
В итоге весь код засран проверками `if (selection != null)`.
**Решение:** Выделение есть всегда. Просто иногда его длина = 0.
Удалить пустое выделение? Легко, удаляем 0 байт. Копировать? Копируем 0 байт.
Логика "нет выделения" нужна юзеру, а не коду. Внутри кода объект должен быть всегда.

## **10.10 Taking it too far**

Убирать ошибки — это круто, но не надо быть идиотом.
Одни студенты в сетевом модуле глотали *все* ошибки. Сеть лежит? Похер, делаем вид, что отправили.
В итоге приложение не знает, что данные не дошли. Это уже не упрощение, это саботаж.
Важные ошибки (информация о которых нужна для принятия решений) скрывать нельзя.

## **10.11 Итог**

Спец-кейсы и исключения — это рак кода.
1. Переопредели семантику так, чтобы ошибок не существовало (пример с `unset` и удалением файлов).
2. Маскируй ошибки на нижнем уровне (как TCP).
3. Агрегируй обработку в одном месте.
4. Если всё плохо — падай.

Чем меньше у тебя `catch` блоков, тем крепче твой сон.