import{_ as e,o as a,c as i,ae as t}from"./chunks/framework.CM3gOIkZ.js";const k=JSON.parse('{"title":"6. Универсальность модулей (General Purpose)","description":"","frontmatter":{},"headers":[],"relativePath":"general-purpose-modules-are-deeper.md","filePath":"general-purpose-modules-are-deeper.md","lastUpdated":1769759266000}'),n={name:"general-purpose-modules-are-deeper.md"};function o(p,s,l,r,d,h){return a(),i("div",null,[...s[0]||(s[0]=[t(`<h1 id="_6-универсальность-модулеи-general-purpose" tabindex="-1"><strong>6. Универсальность модулей (General Purpose)</strong> <a class="header-anchor" href="#_6-универсальность-модулеи-general-purpose" aria-label="Permalink to &quot;**6. Универсальность модулей (General Purpose)**&quot;">​</a></h1><p>Одно из самых частых решений, над которым приходится ломать голову при дизайне нового модуля: пилить его <strong>универсальным</strong> (general-purpose) или заточить под <strong>конкретную задачу</strong> (special-purpose)?</p><p>Одни мамкины архитекторы будут топить за универсальный подход: мол, давай запилим механизм, который решит не только сегодняшние проблемы, но и вообще все возможные проблемы человечества. Типа, вдруг в будущем пригодится, сэкономим время. Это бьется с «инвестиционным подходом» из 3-й главы: потрать время сейчас, чтобы не ебаться потом.</p><p>С другой стороны (и мы все это знаем), предсказывать будущее в IT — дело неблагодарное. В итоге твое «универсальное решение» обрастет функционалом, который нахер никому не нужен. Более того, если сделать что-то <em>слишком</em> общим, оно будет хреново решать ту конкретную задачу, которая горит прямо сейчас. Поэтому адепты YAGNI («You Ain’t Gonna Need It») скажут: не выпендривайся, делай то, что нужно сегодня. А если потом припрет — отрефакторишь. Это такой инкрементальный подход: не плоди сущности без нужды.</p><h2 id="_6-1-делаи-классы-универсальными-general-purpose-а-не-one-off-shit" tabindex="-1"><strong>6.1 Делай классы универсальными (General-purpose, а не one-off shit)</strong> <a class="header-anchor" href="#_6-1-делаи-классы-универсальными-general-purpose-а-не-one-off-shit" aria-label="Permalink to &quot;**6.1 Делай классы универсальными (General-purpose, а не one-off shit)**&quot;">​</a></h2><p>Мой опыт подсказывает, что золотая середина — это модули, которые <strong>«в меру универсальны»</strong> (somewhat general-purpose).</p><p>Что это значит? Функционал модуля должен отражать твои текущие потребности (не надо писать космолет), но вот его <strong>интерфейс</strong> должен быть достаточно общим. Интерфейс должен быть таким, чтобы его можно было заюзать для разных целей, но при этом он должен быть удобным для твоего текущего таска.</p><p>Ключевое слово тут — <strong>«в меру»</strong>. Не надо упарываться и строить абстракцию ради абстракции, которой невозможно пользоваться без бутылки водки.</p><p>Самый жирный (и для многих внезапный) плюс такого подхода: универсальные интерфейсы получаются <strong>проще и глубже</strong>, чем специализированные костыли. Даже если ты никогда не заюзаешь этот модуль повторно, он все равно будет лучше просто потому, что он, сука, проще.</p><h2 id="_6-2-пример-хранение-текста-в-редакторе" tabindex="-1"><strong>6.2 Пример: Хранение текста в редакторе</strong> <a class="header-anchor" href="#_6-2-пример-хранение-текста-в-редакторе" aria-label="Permalink to &quot;**6.2 Пример: Хранение текста в редакторе**&quot;">​</a></h2><p>Возьмем пример из универа. Студентам дали задачу: запилить простенький GUI текстовый редактор. Ну, знаете: открыть файл, потыкать мышкой, напечатать хуйню, сохранить. Нужно было поддержать несколько окон с одним файлом, многоуровневый undo/redo — короче, классика.</p><p>У всех проектов был класс, отвечающий за хранение текста. Загрузить, прочитать, изменить, сохранить.</p><p>Че сделали многие студенты? Они начали лепить <strong>специализированный API</strong> под конкретные кнопки интерфейса. Они знали, что делают редактор, и решили: «О, у нас есть кнопка Backspace и кнопка Delete, давайте сделаем под них методы!».</p><p>Например, Backspace удаляет символ слева от курсора, а Delete — справа. И гении мысли родили в текстовом классе такие методы:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backspace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Cursor cursor);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Cursor cursor);</span></span></code></pre></div><p>Оба метода принимают позицию курсора. А еще была возможность выделить текст и удалить его, поэтому они добавили:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteSelection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Selection selection);</span></span></code></pre></div><p>Студенты думали, что так будет проще пилить UI. Типа, нажал юзер кнопку — вызвали одноименный метод.</p><p>На деле же это <strong>лютый самообстрел</strong>. Такой подход дал ноль пользы для UI-кода, но создал дикую когнитивную нагрузку. Текстовый класс превратился в помойку из кучи мелких, поверхностных (shallow) методов. Каждый метод годился ровно для одной операции. Метод <code>delete</code> вызывался ровно в одном месте программы.</p><p>В итоге:</p><ol><li>Разраб UI должен учить кучу методов текстового класса.</li><li>Произошла <strong>утечка информации</strong> (information leakage). Текстовый класс внезапно знает про какие-то «курсоры», «бэкспейсы» и «выделения».</li><li>UI и логика текста сплелись в клубок целующихся змей. Хочешь добавить новую фичу в интерфейс? Пиздуй переписывать класс текста.</li></ol><h2 id="_6-3-более-общие-интерфеисы" tabindex="-1"><strong>6.3 Более общие интерфейсы</strong> <a class="header-anchor" href="#_6-3-более-общие-интерфеисы" aria-label="Permalink to &quot;**6.3 Более общие интерфейсы**&quot;">​</a></h2><p>А теперь как надо было сделать. Делаем класс текста более общим. Его API должен оперировать понятиями <strong>текста</strong>, а не кнопок в гуе.</p><p>Для изменения текста нам, по сути, нужны всего два метода:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Position position, String newText);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Position start, Position end);</span></span></code></pre></div><p>Всё. Первый вставляет любую строку куда скажешь. Второй выпиливает всё нахер между <code>start</code> и <code>end</code>. И заметьте, мы используем общий тип <code>Position</code>, а не специфичный для UI <code>Cursor</code>.</p><p>Еще добавим утилиту для навигации:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Position </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changePosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Position position, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numChars);</span></span></code></pre></div><p>Этот метод просто двигает позицию на N символов (в плюс или в минус), перескакивая строки если надо.</p><p>Теперь, как реализовать кнопку <strong>Delete</strong> (удаляем символ справа)?</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cursor, text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changePosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cursor, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><p>А как <strong>Backspace</strong> (удаляем символ слева)?</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(text.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">changePosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cursor, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), cursor);</span></span></code></pre></div><p>Да, кода в UI стало чуть больше (целая строчка вместо вызова одного метода!). Но зато этот код <strong>очевиден</strong>. Разраб, который пишет UI, видит: «Ага, мы удаляем от <code>cursor-1</code> до <code>cursor</code>. Понятно, это предыдущий символ». В старом варианте ему пришлось бы лезть в документацию или код метода <code>backspace()</code>, чтобы убедиться, что он делает именно то, что нужно, и не форматирует диск C.</p><p>И главное: сам класс текста стал чище. Вместо зоопарка методов (<code>backspace</code>, <code>delete</code>, <code>deleteSelection</code>, <code>deleteMyHope</code>) у нас один универсальный <code>delete</code>.</p><p>Бонус: такой класс текста можно заюзать где угодно. Например, если ты пишешь тулзу для автозамены слов в файлах. Методы <code>backspace</code> там нахер не нужны, а вот <code>insert</code>, <code>delete</code> и какой-нибудь <code>findNext</code> — это база.</p><h2 id="_6-4-обобщение-помогает-лучше-прятать-кишки" tabindex="-1"><strong>6.4 Обобщение помогает лучше прятать кишки</strong> <a class="header-anchor" href="#_6-4-обобщение-помогает-лучше-прятать-кишки" aria-label="Permalink to &quot;**6.4 Обобщение помогает лучше прятать кишки**&quot;">​</a></h2><p>Универсальный подход четко разделяет ответственность. Текстовому классу насрать, как работает Backspace. Это проблемы UI. Если ты захочешь поменять поведение интерфейса, тебе не надо трогать кишки текстового движка.</p><p>Старый метод <code>backspace</code> в текстовом классе был <strong>фейковой абстракцией</strong> (false abstraction). Он делал вид, что скрывает сложность, но на самом деле просто прятал важные детали (какие именно символы удаляются), которые UI-разрабу <em>нужно</em> знать. Скрывать такую инфу — это не инкапсуляция, это создание мути (obscurity).</p><h2 id="_6-5-вопросы-к-самому-себе-ты-точно-не-идиот" tabindex="-1"><strong>6.5 Вопросы к самому себе (Ты точно не идиот?)</strong> <a class="header-anchor" href="#_6-5-вопросы-к-самому-себе-ты-точно-не-идиот" aria-label="Permalink to &quot;**6.5 Вопросы к самому себе (Ты точно не идиот?)**&quot;">​</a></h2><p>Сделать хороший универсальный интерфейс сложнее, чем накостылять специализированный. Вот вопросы, которые помогут тебе не написать говно:</p><ol><li><p><strong>Какой самый простой интерфейс покроет ВСЕ мои текущие нужды?</strong> Если ты можешь заменить три метода одним (как <code>delete</code> заменил собой <code>backspace</code>, <code>delete</code> и <code>deleteSelection</code>), и при этом не нужно передавать в него 100500 параметров — ты на верном пути.</p></li><li><p><strong>В скольких ситуациях этот метод будет юзаться?</strong> Если метод нужен только для одного конкретного кейса (как <code>backspace</code>) — это <strong>красный флаг</strong>. Это костыль. Попробуй заменить его на что-то более общее.</p></li><li><p><strong>Удобно ли это юзать прямо сейчас?</strong> Тут важно не перегнуть. Можно сделать класс текста, который умеет вставлять и удалять <em>только по одному символу</em>. Это пиздец как универсально и просто. Но писать код на таком API — это боль и куча циклов. Это уже перебор. API должен поддерживать операции над диапазонами (строками), чтобы не быть бесполезным куском кода.</p></li></ol><h2 id="_6-6-итог" tabindex="-1"><strong>6.6 Итог</strong> <a class="header-anchor" href="#_6-6-итог" aria-label="Permalink to &quot;**6.6 Итог**&quot;">​</a></h2><p>Универсальные интерфейсы ебут специализированные. Они проще. У них меньше методов, но эти методы глубже. Они обеспечивают чистую архитектуру и не дают классам протекать друг в друга. Делай свои модули «в меру универсальными» — это один из лучших способов не дать сложности сожрать твой проект.</p>`,44)])])}const g=e(n,[["render",o]]);export{k as __pageData,g as default};
