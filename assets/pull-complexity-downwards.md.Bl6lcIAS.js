import{_ as e,o as t,c as r,ae as a}from"./chunks/framework.CM3gOIkZ.js";const _=JSON.parse('{"title":"8. Скидывай сложность вниз (Pull Complexity Downwards)","description":"","frontmatter":{},"headers":[],"relativePath":"pull-complexity-downwards.md","filePath":"pull-complexity-downwards.md","lastUpdated":1769759266000}'),n={name:"pull-complexity-downwards.md"};function s(l,o,p,d,i,c){return t(),r("div",null,[...o[0]||(o[0]=[a('<h1 id="_8-скидываи-сложность-вниз-pull-complexity-downwards" tabindex="-1"><strong>8. Скидывай сложность вниз (Pull Complexity Downwards)</strong> <a class="header-anchor" href="#_8-скидываи-сложность-вниз-pull-complexity-downwards" aria-label="Permalink to &quot;**8. Скидывай сложность вниз (Pull Complexity Downwards)**&quot;">​</a></h1><p>В этой главе мы поговорим о еще одном способе делать классы «глубокими», а не поверхностными пустышками. Допустим, ты пилишь новый модуль и наткнулся на кусок неизбежной, лютой ебанины (сложности). Возникает вопрос: вывалить эту сложность на тех, кто будет юзать твой модуль, или молча разгрести это дерьмо внутри?</p><p>Если эта сложность хоть как-то касается функционала твоего модуля, то правильный ответ почти всегда второй. У большинства модулей пользователей (других разрабов) больше, чем авторов. Поэтому, с точки зрения гуманизма и здравого смысла, <strong>лучше пусть пострадает один разраб (ты), чем будут вечно мучиться все пользователи твоего кода</strong>.</p><p>Твоя задача как создателя модуля — сделать жизнь юзера максимально сладкой, даже если ради этого тебе придется попотеть и написать пару лишних сотен строк. Перефразируя: <strong>простой интерфейс важнее простой реализации</strong>.</p><p>Но мы же знаем, как работают программисты. Соблазн сделать наоборот велик: решить простые задачки, а сложные — спихнуть на соседа.</p><ul><li>Не знаешь, как обработать ситуацию? Кидай <code>Exception</code>, пусть вызывающий код ебётся.</li><li>Не уверен, какую политику выбрать? Заведи пару параметров в конфиге, пусть сисадмин гадает, какие значения туда вписать.</li></ul><p>Такой подход облегчит твою жизнь здесь и сейчас, но в долгосроке это увеличивает энтропию и пиздец во всей системе. Вместо того чтобы проблему решил один человек (ты), с ней теперь будет трахаться каждый, кто вызовет твой метод. Если класс плюется исключениями, каждый вызов превращается в <code>try-catch</code> ад. Если класс требует настройки, каждый админ на каждой инсталляции будет гуглить мануалы.</p><hr><h2 id="_8-1-пример-текстовыи-редактор-как-сделать-удобно" tabindex="-1"><strong>8.1 Пример: Текстовый редактор (Как сделать удобно)</strong> <a class="header-anchor" href="#_8-1-пример-текстовыи-редактор-как-сделать-удобно" aria-label="Permalink to &quot;**8.1 Пример: Текстовый редактор (Как сделать удобно)**&quot;">​</a></h2><p>Вспомним тот класс для текстового редактора из глав 6 и 7. Он должен читать файл, держать его в памяти и сохранять обратно.</p><p>Когда студентам (читай: джунам) давали это задание, многие выбирали <strong>построчный интерфейс</strong>. Типа методы <code>readLine</code>, <code>insertLine</code>, <code>deleteLine</code>. Почему? Потому что реализовать такую шнягу проще пареной репы.</p><p>Но для того, кто пишет UI поверх этого класса, это <strong>полный ад</strong>. В интерфейсе операции редко касаются целых строк. Юзер нажал клавишу — надо вставить символ в середину строки. Юзер выделил текст и нажал Delete — это может затронуть куски трех разных строк. С «простым» построчным интерфейсом высокоуровневый код вынужден постоянно резать строки, склеивать их обратно и заниматься прочей акробатикой.</p><p>А вот <strong>посимвольный интерфейс</strong> (как в разделе 6.3) — это пример того, как сложность утаскивается вниз. UI-код просто говорит: «удали текст с позиции А по позицию Б», и ему похер на строки. Жить стало проще. Да, реализация самого текстового класса стала сложнее: если внутри всё хранится как массив строк, тебе придется самому их резать и клеить. Но это <strong>правильный подход</strong>. Ты инкапсулируешь (прячешь) этот геморрой внутри класса, снижая общую сложность системы. Говно не плавает на поверхности, оно надежно спрятано в трубах.</p><hr><h2 id="_8-2-пример-параметры-конфигурации-админ-разберется-или-нет" tabindex="-1"><strong>8.2 Пример: Параметры конфигурации (Админ разберется... или нет)</strong> <a class="header-anchor" href="#_8-2-пример-параметры-конфигурации-админ-разберется-или-нет" aria-label="Permalink to &quot;**8.2 Пример: Параметры конфигурации (Админ разберется... или нет)**&quot;">​</a></h2><p>Конфиги — это классический пример того, как сложность всплывает наверх, вместо того чтобы тонуть. Вместо того чтобы решить, как системе работать, класс говорит: «Я хз, вот вам параметры <code>cache_size</code> и <code>retry_count</code>, сами разбирайтесь». Сейчас модно делать системы с сотнями параметров.</p><p>Адепты этого подхода кукарекают, что это круто: мол, юзеры могут «тюнить» систему под себя. Иногда это правда — низкоуровневый код не может знать всё о контексте. Но будем честны: чаще всего конфиги — это просто <strong>отмазка</strong>, чтобы не решать сложные вопросы.</p><p>В большинстве случаев юзеры (и даже админы) в душе не ебут, какие значения там выставлять. Часто правильные значения можно вычислить автоматически, если не лениться.</p><p>Возьмем сетевой протокол. Пакеты теряются, надо делать повторную отправку (retry). Сколько ждать перед повтором?</p><ul><li><strong>Ленивый путь:</strong> Сделать параметр <code>retry_interval</code> в конфиге. Пусть юзер гадает.</li><li><strong>Нормальный путь:</strong> Протокол сам замеряет время ответа успешных запросов и на основе этого динамически вычисляет таймаут.</li></ul><p>Второй подход утаскивает сложность вниз. Юзеру не надо думать. Более того, система адаптируется сама, если сеть начнет тупить. А жестко забитый конфиг устареет и станет бесполезным куском говна.</p><p><strong>Совет:</strong> Избегай конфигурационных параметров как чумы. Перед тем как добавить новый, спроси себя: «А юзер реально сможет определить это значение лучше, чем мой код?». Если уж приходится делать конфиг — сделай так, чтобы дефолтные значения работали в 99% случаев, и юзер лез туда только в случае ядерной войны. Идеальный модуль решает проблему целиком. Конфиги — это признак недоделанного решения.</p><hr><h2 id="_8-3-когда-перегнул-палку-не-надо-делать-из-модуля-черную-дыру" tabindex="-1"><strong>8.3 Когда перегнул палку (Не надо делать из модуля чёрную дыру)</strong> <a class="header-anchor" href="#_8-3-когда-перегнул-палку-не-надо-делать-из-модуля-черную-дыру" aria-label="Permalink to &quot;**8.3 Когда перегнул палку (Не надо делать из модуля чёрную дыру)**&quot;">​</a></h2><p>Утаскивать сложность вниз надо с умом. Если перегнуть палку, можно получить «Божественный Объект» (God Class), который делает вообще всё. Это тоже дичь.</p><p>Спускать сложность имеет смысл, если: а) Эта сложность тесно связана с функционалом класса. б) Это упростит жизнь всем остальным частям программы. в) Интерфейс класса станет чище.</p><p>В главе 6 был пример, где студенты пихали в текстовый класс логику кнопки Backspace. Казалось бы — утащили сложность вниз? Нет, нихуя. Знание о том, как работает Backspace — это уровень UI. Пихая это в класс хранения данных, ты не упрощаешь систему, а смешиваешь слои ответственности. Это называется <strong>утечка информации</strong> (information leakage), и это плохо. Не надо путать «спрятать сложность реализации» и «свалить всё в одну кучу».</p><hr><h2 id="_8-4-итог" tabindex="-1"><strong>8.4 Итог</strong> <a class="header-anchor" href="#_8-4-итог" aria-label="Permalink to &quot;**8.4 Итог**&quot;">​</a></h2><p>Когда пишешь модуль, ищи возможность взять на себя чуть больше страданий, чтобы твоим пользователям жилось чуть легче. Будь мужиком, разгреби сложность сам.</p>',30)])])}const h=e(n,[["render",s]]);export{_ as __pageData,h as default};
