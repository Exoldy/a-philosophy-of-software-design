import{_ as t,o as r,c as n,ae as s}from"./chunks/framework.CM3gOIkZ.js";const p=JSON.parse('{"title":"Краткое резюме принципов дизайна (Шпаргалка)","description":"","frontmatter":{},"headers":[],"relativePath":"summary.md","filePath":"summary.md","lastUpdated":1769760828000}'),i={name:"summary.md"};function e(l,o,a,g,d,c){return r(),n("div",null,[...o[0]||(o[0]=[s('<h1 id="краткое-резюме-принципов-дизаина-шпаргалка" tabindex="-1"><strong>Краткое резюме принципов дизайна (Шпаргалка)</strong> <a class="header-anchor" href="#краткое-резюме-принципов-дизаина-шпаргалка" aria-label="Permalink to &quot;**Краткое резюме принципов дизайна (Шпаргалка)**&quot;">​</a></h1><p>Вот самые важные принципы дизайна софта из этой книги. Распечатай и повесь над монитором:</p><ol><li><strong>Сложность растёт как снежный ком:</strong> забей хуй на мелочи сегодня, и завтра этот ком тебя раздавит (см. стр. 11).</li><li><strong>«Оно работает» — это не оправдание.</strong> Это, блять, необходимый минимум, а не достижение (см. стр. 14).</li><li><strong>Инвестируй в дизайн постоянно.</strong> По чуть-чуть, каждый день, а не устраивай героические субботники раз в год (см. стр. 15).</li><li><strong>Модули должны быть глубокими.</strong> Мощный функционал за узким интерфейсом, а не наоборот (см. стр. 22).</li><li><strong>Интерфейсы должны быть простыми.</strong> Сделай так, чтобы типичную задачу мог решить даже джун с похмелья, не заглядывая в мануал (см. стр. 27).</li><li><strong>Простой интерфейс важнее простой реализации.</strong> Пусть внутри творится ад и содомия, но снаружи всё должно быть красиво и понятно (см. стр. 55, 71).</li><li><strong>Универсальные модули — глубже.</strong> Чем абстрактнее херня, тем она полезнее в хозяйстве (см. стр. 39).</li><li><strong>Мухи — отдельно, котлеты — отдельно.</strong> Не мешай код общего назначения со специфическим бизнес-говном (см. стр. 62).</li><li><strong>Разные слои — разные абстракции.</strong> Не надо гонять одни и те же данные туда-сюда, меняя только название переменной (см. стр. 45).</li><li><strong>Спускай сложность вниз.</strong> Пусть страдает модуль, а не тот, кто его вызывает (см. стр. 55).</li><li><strong>Уничтожай ошибки на этапе дизайна.</strong> Спроектируй так, чтобы корнер-кейсов тупо не могло возникнуть. Нет ошибки — нет эксепшена (см. стр. 79).</li><li><strong>Спроектируй дважды.</strong> Первое решение, которое пришло тебе в голову, скорее всего — говно. Смирись и переделай (см. стр. 91).</li><li><strong>Комменты должны объяснять то, чего нет в коде.</strong> Не пиши «i++ // увеличиваем i», за это в приличных домах бьют канделябром (см. стр. 101).</li><li><strong>Код должен легко читаться, а не легко писаться.</strong> Тебе его писать один раз, а читать — сотни. Пожалей глаза коллег (см. стр. 149).</li><li><strong>Развивай проект абстракциями, а не фичами.</strong> Не будь «фиче-клепателем», будь инженером (см. стр. 154).</li></ol><hr><h2 id="красные-флаги-симптомы-того-что-ты-кодишь-как-мудак" tabindex="-1"><strong>Красные флаги (Симптомы того, что ты кодишь как мудак)</strong> <a class="header-anchor" href="#красные-флаги-симптомы-того-что-ты-кодишь-как-мудак" aria-label="Permalink to &quot;**Красные флаги (Симптомы того, что ты кодишь как мудак)**&quot;">​</a></h2><p>Если видишь что-то из этого списка в своём проекте — у меня для тебя плохие новости, дизайн прогнил:</p><ul><li><strong>Мелкий модуль (Shallow Module):</strong> Интерфейс класса такой же сложный, как и его реализация. Пользы ноль, геморроя много (см. стр. 25, 110).</li><li><strong>Протечка информации (Information Leakage):</strong> Одно дизайнерское решение размазано тонким слоем по нескольким модулям. Поменял в одном месте — всё наебнулось в трех других (см. стр. 31).</li><li><strong>Временнáя декомпозиция (Temporal Decomposition):</strong> Код разбит по принципу «сначала делаем это, потом то», а не по смыслу. Привет, процедурное программирование из 80-х (см. стр. 32).</li><li><strong>Эксгибиционизм (Overexposure):</strong> API заставляет юзера знать о какой-то редкой, никому не нужной херне, просто чтобы вызвать базовую функцию (см. стр. 36).</li><li><strong>Метод-перекладыватель (Pass-Through Method):</strong> Метод, который не делает нихуя, кроме как пинает аргументы соседнему методу. Бесполезная прокладка (см. стр. 46).</li><li><strong>Копипаста (Repetition):</strong> Нетривиальный кусок кода повторяется снова и снова. DRY, сука, Do You Speak It? (см. стр. 62).</li><li><strong>Винегрет (Special-General Mixture):</strong> Специализированный код свален в кучу с общим. Разгребать это — отдельный вид пытки (см. стр. 65).</li><li><strong>Сиамские близнецы (Conjoined Methods):</strong> Два метода так сплелись зависимостями, что хер поймешь один без другого (см. стр. 72).</li><li><strong>Капитан Очевидность (Comment Repeats Code):</strong> В комменте написано ровно то же самое, что и в коде рядом. Спасибо, кэп (см. стр. 104).</li><li><strong>Спойлеры реализации (Implementation Documentation Contaminates Interface):</strong> В доке к интерфейсу описано, как оно работает внутри. Юзеру похуй на твои кишки, не грузи его (см. стр. 114).</li><li><strong>Мутное имя (Vague Name):</strong> Название переменной или метода настолько расплывчатое, что не несет никакой инфы. <code>data</code>, <code>handle</code>, <code>manager</code> — я смотрю на вас (см. стр. 123).</li><li><strong>Нейминг не идет (Hard to Pick Name):</strong> Если не можешь нормально назвать сущность — значит, ты сам не понимаешь, на кой хер она нужна, или она делает слишком дохера всего (см. стр. 125).</li><li><strong>Хрен опишешь (Hard to Describe):</strong> Если документация к методу занимает больше места, чем сам метод, значит дизайн — говно (см. стр. 131).</li><li><strong>Магия (Nonobvious Code):</strong> Код работает, но никто, блять, не понимает как. Поведение неочевидно (см. стр. 148).</li></ul><hr><h2 id="об-авторе-кто-этот-мощныи-старик" tabindex="-1"><strong>Об авторе (Кто этот мощный старик?)</strong> <a class="header-anchor" href="#об-авторе-кто-этот-мощныи-старик" aria-label="Permalink to &quot;**Об авторе (Кто этот мощный старик?)**&quot;">​</a></h2><p><strong>Джон Оустерхаут</strong> — профессор Computer Science в Стэнфорде, не хрен с горы. Отец-основатель скриптового языка Tcl (да, того самого, про который ты слышал от седобородых админов) и собаку съел на распределенных операционках и системах хранения.</p><p>У мужика бакалавр по физике из Йеля и PhD по Computer Science из Карнеги-Меллон. Короче, умнее нас всех вместе взятых. Член Национальной инженерной академии, обвешан наградами как новогодняя ёлка: ACM Software System Award, премия имени Грейс Мюррей Хоппер и прочие ачивки, которые тебе не светят.</p>',11)])])}const u=t(i,[["render",e]]);export{p as __pageData,u as default};
