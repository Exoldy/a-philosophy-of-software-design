import{_ as t,o as s,c as e,ae as i}from"./chunks/framework.CM3gOIkZ.js";const c=JSON.parse('{"title":"5. Прячем говно под ковер (Сокрытие информации и утечки)","description":"","frontmatter":{},"headers":[],"relativePath":"information-hiding-and-leakage.md","filePath":"information-hiding-and-leakage.md","lastUpdated":1769733417000}'),o={name:"information-hiding-and-leakage.md"};function n(r,a,l,p,h,d){return s(),e("div",null,[...a[0]||(a[0]=[i(`<h1 id="_5-прячем-говно-под-ковер-сокрытие-информации-и-утечки" tabindex="-1"><strong>5. Прячем говно под ковер (Сокрытие информации и утечки)</strong> <a class="header-anchor" href="#_5-прячем-говно-под-ковер-сокрытие-информации-и-утечки" aria-label="Permalink to &quot;**5. Прячем говно под ковер (Сокрытие информации и утечки)**&quot;">​</a></h1><p>В прошлой главе мы выяснили, что модули должны быть глубокими. В этой (и следующих) главах мы разберем техники, как сделать так, чтобы твой код был действительно глубоким, а не просто запутанным куском... ну ты понял.</p><h2 id="_5-1-сокрытие-информации-инкапсуляция-для-взрослых" tabindex="-1"><strong>5.1 Сокрытие информации (Инкапсуляция для взрослых)</strong> <a class="header-anchor" href="#_5-1-сокрытие-информации-инкапсуляция-для-взрослых" aria-label="Permalink to &quot;**5.1 Сокрытие информации (Инкапсуляция для взрослых)**&quot;">​</a></h2><p>Самая главная техника для создания глубоких модулей — это <strong>сокрытие информации</strong>. Эту фишку придумал Дэвид Парнас ещё в лохматые 70-е. Базовая идея проста: каждый модуль должен инкапсулировать (читай: прятать внутри себя) кусок знаний о том, как всё устроено. Эти знания живут внутри реализации, но в интерфейсе их не видно. Другим модулям вообще не всралось знать, что у тебя там под капотом.</p><p>Обычно прячут детали реализации механизмов. Примеры того, что нормальные люди прячут внутри модуля:</p><ul><li>Как хранить данные в B-дереве и искать их там, не умирая от старости.</li><li>Как мапить логические блоки файла на физические сектора диска (тебе оно надо?).</li><li>Как на самом деле работает протокол TCP (поверь, ты не хочешь этого знать).</li><li>Как шедулить потоки на многоядерном проце.</li><li>Как парсить этот сраный JSON.</li></ul><hr><p>Скрытая инфа — это структуры данных и алгоритмы. Это могут быть низкоуровневые детали (типа размера страницы памяти) или высокоуровневые абстракции (типа предположения, что &quot;большинство файлов маленькие, так что похер&quot;).</p><p>Сокрытие информации снижает сложность двумя путями:</p><ol><li><strong>Упрощает интерфейс.</strong> Интерфейс становится чище и абстрактнее. Это снижает когнитивную нагрузку на разраба. Если ты юзаешь класс B-дерева, тебе насрать на балансировку узлов. Ты просто говоришь: &quot;Найди мне X&quot;, и оно находит.</li><li><strong>Упрощает эволюцию системы.</strong> Если ты спрятал кишки модуля внутри, то снаружи от них никто не зависит. Захотел поменять реализацию TCP? Меняй. Верхнеуровневый код, который просто шлет байтики, даже не чихнет.</li></ol><p><strong>Совет:</strong> Когда дизайнишь новый модуль, крепко подумай, какую инфу можно заныкать. Чем больше ты спрячешь, тем проще будет интерфейс, и тем глубже будет модуль.</p><p><strong>Важное примечание:</strong> Объявить переменные и методы <code>private</code> — это еще не сокрытие информации. Если ты сделал переменную приватной, но налепил к ней публичные геттеры и сеттеры, то ты, по сути, просто выставил её напоказ. Ты ничего не спрятал, ты просто добавил бюрократии.</p><p>Лучшая форма сокрытия — когда инфа вообще не видна снаружи. Но частичное сокрытие тоже катит. Если какая-то фича нужна только паре фриков, спрячь её за отдельными методами, чтобы нормальные люди не спотыкались об неё в основных сценариях.</p><h2 id="_5-2-утечки-информации-когда-кишки-торчат-наружу" tabindex="-1"><strong>5.2 Утечки информации (Когда кишки торчат наружу)</strong> <a class="header-anchor" href="#_5-2-утечки-информации-когда-кишки-торчат-наружу" aria-label="Permalink to &quot;**5.2 Утечки информации (Когда кишки торчат наружу)**&quot;">​</a></h2><p>Противоположность сокрытия — <strong>утечка информации</strong>. Это когда твое &quot;гениальное&quot; архитектурное решение размазано по нескольким модулям. Это создает зависимость: поменял что-то в одном месте — иди правь в пяти других.</p><p>Если деталь реализации торчит в интерфейсе — это официальная утечка. Но бывает и хуже: <strong>скрытая утечка</strong>. Представь два класса, которые оба знают про формат какого-то файла. Даже если они не светят это в интерфейсе, они оба зависят от этого формата. Поменял формат — переписывай оба класса. Такая утечка через задний проход (back-door leakage) — самая подлая херня, потому что её не видно сразу.</p><p>Утечка информации — это жирнющий красный флаг. Хороший дизайнер чует утечку за версту. Видишь утечку? Спроси себя: &quot;Как мне перетасовать классы так, чтобы это знание жило только в одном месте?&quot;. Иногда проще слить два мелких класса в один большой, чем трахаться с зависимостями. Или вынести эту инфу в третий, новый класс. Но только если у него будет простой интерфейс, иначе ты просто переложил говно из одной кучи в другую.</p><blockquote><p><strong>АХТУНГ: Утечка информации</strong> Утечка происходит, когда одно и то же знание используется в разных местах. Например, два разных класса знают структуру одного файла. Поменяешь файл — сломаешь оба класса.</p></blockquote><h2 id="_5-3-временная-декомпозиция-зло-во-плоти" tabindex="-1"><strong>5.3 Временная декомпозиция (Зло во плоти)</strong> <a class="header-anchor" href="#_5-3-временная-декомпозиция-зло-во-плоти" aria-label="Permalink to &quot;**5.3 Временная декомпозиция (Зло во плоти)**&quot;">​</a></h2><p>Частая причина утечек — стиль дизайна, который я называю <strong>временнóй декомпозицией</strong>. Это когда ты структурируешь систему по порядку действий во времени.</p><p>Типа: &quot;Сначала мы читаем файл, потом меняем данные, потом пишем файл&quot;. И ты, недолго думая, пилишь три класса: <code>FileReader</code>, <code>DataModifier</code>, <code>FileWriter</code>. В итоге и читатель, и писатель знают про формат файла. Поздравляю, у тебя утечка.</p><p>Решение: запихни чтение и запись в один класс, который шарит за формат файла. В ловушку временной декомпозиции легко попасть, потому что ты, когда кодишь, думаешь алгоритмом: &quot;сначала это, потом то&quot;. Но архитектура должна строиться вокруг <strong>знаний</strong>, а не вокруг <strong>порядка действий</strong>.</p><blockquote><p><strong>АХТУНГ: Временная декомпозиция</strong> Это когда структура кода повторяет порядок выполнения. Операции, которые происходят в разное время, разлетаются по разным классам. Если одно знание нужно на разных этапах, оно дублируется, и мы получаем утечку.</p></blockquote><h2 id="_5-4-пример-http-сервер-разбор-полетов" tabindex="-1"><strong>5.4 Пример: HTTP сервер (Разбор полетов)</strong> <a class="header-anchor" href="#_5-4-пример-http-сервер-разбор-полетов" aria-label="Permalink to &quot;**5.4 Пример: HTTP сервер (Разбор полетов)**&quot;">​</a></h2><p>Давайте посмотрим на студентов, которые писали HTTP-сервер. На их ошибках учиться веселее.</p><p>HTTP — это протокол, по которому браузер базарит с сервером. Запрос — это текст. Студентам надо было написать классы для приема запросов и отправки ответов.</p><p><em>(Тут была картинка с HTTP запросом, но ты и так знаешь, как выглядит POST-запрос, не маленький).</em></p><h2 id="_5-5-пример-слишком-дохера-классов" tabindex="-1"><strong>5.5 Пример: Слишком дохера классов</strong> <a class="header-anchor" href="#_5-5-пример-слишком-дохера-классов" aria-label="Permalink to &quot;**5.5 Пример: Слишком дохера классов**&quot;">​</a></h2><p>Главный косяк студентов — они наплодили кучу мелких, плоских классов. Одна команда сделала два класса для приема запроса: первый вычитывает байты из сокета в строку, второй парсит эту строку. Это классическая <strong>временная декомпозиция</strong>: &quot;сначала читаем, потом парсим&quot;. Проблема в том, что ты не можешь нормально прочитать запрос, не распарсив его (тебе надо знать <code>Content-Length</code>, чтобы понять, сколько читать). В итоге оба класса должны знать структуру HTTP. Код дублируется, сложность растет, вызывающий код должен дергать два метода в строгом порядке. Бред.</p><p>Было бы лучше слить их в один класс. Это улучшает сокрытие информации (все знания о формате HTTP в одном месте) и упрощает жизнь (вызвал один метод и забыл).</p><p>Этот пример иллюстрирует важную мысль: <strong>иногда жирный класс — это хорошо</strong>. Объединение кода в одном месте позволяет спрятать кишки и дать наружу простой интерфейс.</p><p>Конечно, не надо делать <code>GodObject</code>, который делает вообще всё. Но об этом в 9-й главе.</p><h2 id="_5-6-пример-обработка-параметров-http" tabindex="-1"><strong>5.6 Пример: Обработка параметров HTTP</strong> <a class="header-anchor" href="#_5-6-пример-обработка-параметров-http" aria-label="Permalink to &quot;**5.6 Пример: Обработка параметров HTTP**&quot;">​</a></h2><p>Серверу нужно достать параметры из запроса (типа <code>photo_id</code> или <code>comment</code>). Они могут быть в URL, могут быть в теле, и они еще закодированы (всякие <code>%20</code> вместо пробелов).</p><p>Что студенты сделали хорошо:</p><ol><li>Спрятали разницу между параметрами в URL и в теле. Вызывающему пофиг, где был параметр.</li><li>Спрятали URL-декодирование. Сервер отдает уже нормальный текст &quot;Hello World&quot;, а не &quot;Hello%20World&quot;.</li></ol><p>Где они облажались: Почти все сделали метод типа такого:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">String, String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getParams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.params;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Это, блядь, фиаско. Метод возвращает ссылку на внутреннюю <code>Map</code>.</p><ol><li>Это <strong>плоский интерфейс</strong>. Ты вываливаешь свои кишки (внутреннюю структуру данных) наружу. Захочешь поменять <code>Map</code> на что-то другое — переписывай весь проект.</li><li>Это неудобно. Юзеру надо вызвать <code>getParams()</code>, получить карту, потом дергать карту.</li><li>Это опасно. Юзер может случайно (или специально) поменять эту карту и сломать состояние объекта <code>HTTPRequest</code>.</li></ol><p>Нормальный пацанский интерфейс выглядит так:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name) { ... }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getIntParameter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String name) { ... }</span></span></code></pre></div><p><code>getParameter</code> прячет структуру хранения. <code>getIntParameter</code> сразу парсит строку в число. Это удобно: не надо самому делать <code>Integer.parseInt</code> и ловить эксепшены каждый раз. Это пример <strong>глубокого интерфейса</strong>.</p><h2 id="_5-7-пример-дефолтные-значения-в-ответах" tabindex="-1"><strong>5.7 Пример: Дефолтные значения в ответах</strong> <a class="header-anchor" href="#_5-7-пример-дефолтные-значения-в-ответах" aria-label="Permalink to &quot;**5.7 Пример: Дефолтные значения в ответах**&quot;">​</a></h2><p>Еще одна боль — создание ответов. Студенты заставляли юзера указывать версию HTTP при создании ответа. Алло! Версия ответа должна совпадать с версией запроса. Библиотека сама знает запрос, пусть сама и подставит версию. Юзер вообще может не знать, какая там версия. То же самое с датой (<code>Date</code> header). Библиотека должна ставить текущее время по дефолту.</p><p><strong>Дефолты</strong> — это круто. Они делают интерфейс простым для 99% случаев. Если кому-то реально надо переопределить дату — дай ему отдельный метод. Но по умолчанию всё должно работать &quot;из коробки&quot;.</p><p>Хороший класс должен делать правильные вещи, не заставляя тебя умолять об этом. Плохой пример — Java I/O. Чтобы получить буферизацию (которая нужна всем и всегда), ты должен явно обернуть стрим в <code>BufferedInputStream</code>. Какого хера? Оно должно быть включено по дефолту! Лучшие фичи — это те, о существовании которых ты даже не догадываешься, потому что они просто работают.</p><blockquote><p><strong>АХТУНГ: Эксгибиционизм в API</strong> Если для простой задачи API заставляет меня изучать настройки, которые нужны раз в сто лет — это плохой дизайн. Это грузит мозг.</p></blockquote><h2 id="_5-8-прячем-инфу-внутри-класса" tabindex="-1"><strong>5.8 Прячем инфу внутри класса</strong> <a class="header-anchor" href="#_5-8-прячем-инфу-внутри-класса" aria-label="Permalink to &quot;**5.8 Прячем инфу внутри класса**&quot;">​</a></h2><p>Сокрытие работает не только для публичных API. Внутри класса тоже надо прятать говно. Дизайни приватные методы и переменные так, чтобы минимизировать доступ к ним. Если переменная используется во всем классе — это повод напрячься. Если можно ограничить её использование парой методов — сделай это. Чем меньше мест, где трогают данные, тем меньше шансов, что какой-то джун их запорет.</p><h2 id="_5-9-когда-перегнул-палку-заставь-дурака-богу-молиться" tabindex="-1"><strong>5.9 Когда перегнул палку (Заставь дурака богу молиться...)</strong> <a class="header-anchor" href="#_5-9-когда-перегнул-палку-заставь-дурака-богу-молиться" aria-label="Permalink to &quot;**5.9 Когда перегнул палку (Заставь дурака богу молиться...)**&quot;">​</a></h2><p>Сокрытие имеет смысл, только если инфа не нужна снаружи. Если параметр реально нужен юзеру для настройки производительности — <strong>не прячь его</strong>. Выставь его в интерфейс. Твоя цель — минимизировать инфу, которая <em>нужна</em> снаружи, а не скрывать то, без чего работать невозможно. Если модуль может настроиться сам — круто. Если нет — дай ручку настройки, не будь мудаком.</p><h2 id="_5-10-итог" tabindex="-1"><strong>5.10 Итог</strong> <a class="header-anchor" href="#_5-10-итог" aria-label="Permalink to &quot;**5.10 Итог**&quot;">​</a></h2><p>Сокрытие информации и глубокие модули — это братья навек. Чем больше ты прячешь, тем глубже модуль. Чем больше ты вываливаешь наружу, тем он более плоский и убогий.</p><p>Когда нарезаешь систему на модули:</p><ol><li>Забей на порядок действий во времени (это путь к временной декомпозиции и страданиям).</li><li>Думай о <strong>знаниях</strong>.</li><li>Инкапсулируй каждое знание в отдельный модуль.</li></ol><p>Так победишь.</p>`,57)])])}const k=t(o,[["render",n]]);export{c as __pageData,k as default};
