import{_ as s,o as t,c as e,ae as i}from"./chunks/framework.CM3gOIkZ.js";const c=JSON.parse('{"title":"16. Трогаем старый код (Некромантия и Рефакторинг)","description":"","frontmatter":{},"headers":[],"relativePath":"modifying-existing-code.md","filePath":"modifying-existing-code.md","lastUpdated":1769759266000}'),o={name:"modifying-existing-code.md"};function n(r,a,l,p,d,g){return t(),e("div",null,[...a[0]||(a[0]=[i(`<h1 id="_16-трогаем-старыи-код-некромантия-и-рефакторинг" tabindex="-1"><strong>16. Трогаем старый код (Некромантия и Рефакторинг)</strong> <a class="header-anchor" href="#_16-трогаем-старыи-код-некромантия-и-рефакторинг" aria-label="Permalink to &quot;**16. Трогаем старый код (Некромантия и Рефакторинг)**&quot;">​</a></h1><p>Как тебе уже пояснили в первой главе, разработка софта — это, сука, итеративный процесс. Крупная система растет через стадии эволюции, как покемон, только вместо новых абилок она обрастает легаси и костылями. Дизайн системы вечно мутирует.</p><p>Сразу придумать идеальную архитектуру <strong>невозможно</strong>, даже не пытайся. Дизайн зрелой системы определяется не тем, что ты там нафантазировал на старте, а тем, как её насиловали правками в процессе жизни. В прошлых главах мы говорили, как не наговнокодить с нуля; в этой поговорим, как не дать энтропии и пиздецу поглотить проект, когда он уже запущен.</p><h2 id="_16-1-оставаися-стратегом-не-скатываися-в-лишь-бы-заработало" tabindex="-1"><strong>16.1 Оставайся стратегом (Не скатывайся в &quot;лишь бы заработало&quot;)</strong> <a class="header-anchor" href="#_16-1-оставаися-стратегом-не-скатываися-в-лишь-бы-заработало" aria-label="Permalink to &quot;**16.1 Оставайся стратегом (Не скатывайся в &quot;лишь бы заработало&quot;)**&quot;">​</a></h2><p>В 3-й главе мы уже перетирали за разницу между тактическим («хуяк-хуяк и в продакшн») и стратегическим программированием.</p><ul><li><strong>Тактика:</strong> Главное, чтобы работало <em>сейчас</em>. Даже если код выглядит как блевотина.</li><li><strong>Стратегия:</strong> Главное — крутой дизайн системы.</li></ul><p>Тактический подход мгновенно превращает проект в помойку. Если ты хочешь систему, которую можно поддерживать, критерий «оно работает» — это для лохов. Ты должен думать о дизайне, даже когда просто ковыряешь старый код.</p><p>Но реальность сурова. Когда разрабы лезут чинить баги или пилить фичи в старом коде, у них отключается мозг и включается режим ссыкла. Типичная мысль: <em>«Какое минимальное изменение я могу сделать, чтобы ничего не сломать и свалить домой?»</em>. Они боятся кода. Они думают, что серьезный рефакторинг принесет новые баги. Но этот страх порождает <strong>тактическое говнокодерство</strong>. Каждая такая «минимальная правка» добавляет новый if-чик, лишнюю зависимость или спец-кейс. В итоге система гниет с каждым коммитом.</p><p>Хочешь чистый код? Будь мужиком, включай стратегическое мышление. После твоей правки код должен выглядеть так, как будто эта фича была там задумана изначально архитекторами из NASA. Видишь искушение сделать быстрый фикс? Бей себя по рукам. Подумай: подходит ли текущий дизайн под новую задачу? Если нет — <strong>рефактори, сука</strong>. Только так дизайн становится лучше, а не скатывается в сраное болото.</p><p>Это та самая «инвестиция», о которой говорили на 15-й странице. Потратишь лишний час на рефакторинг сейчас — сэкономишь дни потом. Если ты трогаешь код и не делаешь дизайн лучше, ты, скорее всего, делаешь его хуже.</p><p>Конечно, иногда бизнес держит паяльник у твоей жопы. Если правильный рефакторинг займет три месяца, а быстрый грязный хак — два часа, и дедлайн был вчера — придется говнокодить. Но сопротивляйся этому до последнего! Спроси себя: «Это реально лучшее, что я могу сделать в этих скотских условиях?». Может, можно сделать не идеально, но хотя бы не совсем убого за пару дней? Каждая контора должна выделять время на разгребание технического долга, иначе этот долг вас похоронит.</p><h2 id="_16-2-держи-комменты-рядом-с-кодом-а-не-в-голове-или-в-jira" tabindex="-1"><strong>16.2 Держи комменты рядом с кодом (А не в голове или в Jira)</strong> <a class="header-anchor" href="#_16-2-держи-комменты-рядом-с-кодом-а-не-в-голове-или-в-jira" aria-label="Permalink to &quot;**16.2 Держи комменты рядом с кодом (А не в голове или в Jira)**&quot;">​</a></h2><p>Когда ты меняешь код, старые комменты превращаются в наглый пиздёж. Забыть обновить коммент — святое дело. В итоге читатель видит одно, а код делает другое. Это бесит, и люди перестают верить комментам вообще. Но есть способ не быть мудаком.</p><p><strong>Держи комменты рядом с кодом.</strong> Чем дальше описание от мяса, тем меньше шансов, что ты его вспомнишь поправить. Например, описание интерфейса метода должно быть прямо над методом в файле с кодом. Ты всё равно туда полезешь править логику, увидишь коммент и (возможно) обновишь его.</p><p>Любители C/C++ сейчас начнут ныть про хедеры (.h файлы). Мол, интерфейс там. Но это далеко от тела функции. Разрабу лень открывать другой файл, чтобы поправить текст. Некоторые говорят: «Хедеры нужны, чтобы юзер видел API и не смотрел в кишки кода». Да срать я хотел на это. Юзеры должны читать доку, сгенерированную Doxygen или Javadoc, а не лазить по сырцам. А IDE сейчас умные, сами подтянут доку куда надо. Так что пиши там, где удобно <strong>тебе</strong> — рядом с кодом.</p><p>Внутри метода не надо сваливать все комменты в кучу сверху. Размажь их по коду. <em>Пример:</em> Вместо стены текста в начале, сделай так:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// План капкан (3 фазы):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Ищем кандидатов</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Ставим им оценки</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. Выбираем лучшего и выкидываем на мороз</span></span></code></pre></div><p>А детали пиши уже перед конкретными блоками кода. <strong>Правило:</strong> Чем дальше коммент от кода, тем более абстрактным он должен быть, чтобы не протухнуть при первой же мелкой правке.</p><h2 id="_16-3-комменты-принадлежат-коду-а-не-логам-коммитов-git-blame-не-спасет" tabindex="-1"><strong>16.3 Комменты принадлежат коду, а не логам коммитов (Git blame не спасет)</strong> <a class="header-anchor" href="#_16-3-комменты-принадлежат-коду-а-не-логам-коммитов-git-blame-не-спасет" aria-label="Permalink to &quot;**16.3 Комменты принадлежат коду, а не логам коммитов (Git blame не спасет)**&quot;">​</a></h2><p>Классическая ошибка долбоёба: расписать причину сложного изменения в Commit Message, а в коде оставить пустоту. Ты реально думаешь, что через год кто-то будет копаться в <code>git log</code>, чтобы понять, почему тут стоит этот костыль? Хер там. Даже если полезут, хрен найдут.</p><p>Пишешь коммит? Спроси себя: «Эта инфа пригодится потомкам?». Если да — <strong>пиши её в код</strong>. Пример: ты пофиксил хитрый баг. Если не написать об этом в коде, придет новый «умный» разраб, увидит «странный код», удалит твой фикс и вернет баг обратно. Git log — это кладбище истории, туда никто не ходит без крайней нужды. Код — вот где живут знания.</p><h2 id="_16-4-избегаи-дублирования-dry-в-документации-тоже-работает" tabindex="-1"><strong>16.4 Избегай дублирования (DRY в документации тоже работает)</strong> <a class="header-anchor" href="#_16-4-избегаи-дублирования-dry-в-документации-тоже-работает" aria-label="Permalink to &quot;**16.4 Избегай дублирования (DRY в документации тоже работает)**&quot;">​</a></h2><p>Второй способ держать комменты свежими — <strong>не копипастить</strong>. Если одно и то же написано в трех местах, ты поменяешь в одном и забудешь в двух других. Поздравляю, у тебя рассинхрон. Найди <strong>одно</strong> место для доки. В остальных поставь ссылку: <em>«Смотри описание переменной X, там всё разжевано»</em>. Если ссылка протухнет — это сразу видно (коммента нет), а если протухнет текст копипасты — ты будешь дебажить этот обман часами.</p><p>Если идеального места нет — создай файл <code>designNotes</code>.</p><p>И не надо пересказывать в комментах то, что делает другой модуль. Или переписывать спецификацию HTTP. <em>Пример:</em></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Реализует команду Foo. Читай мануал, там всё есть. Ссылка вот.</span></span></code></pre></div><p>Не пытайся переписать весь интернет в своих комментах. Просто дай ссылку.</p><h2 id="_16-5-проверяи-дифы-check-diffs-не-будь-животным-смотри-что-комитишь" tabindex="-1"><strong>16.5 Проверяй дифы (Check diffs): Не будь животным, смотри, что комитишь</strong> <a class="header-anchor" href="#_16-5-проверяи-дифы-check-diffs-не-будь-животным-смотри-что-комитишь" aria-label="Permalink to &quot;**16.5 Проверяй дифы (Check diffs): Не будь животным, смотри, что комитишь**&quot;">​</a></h2><p>Перед тем как набрать <code>git commit</code>, потрать две минуты и посмотри <code>git diff</code>. Пробегись глазами по тому, что ты наворотил. Это лучший способ заметить, что ты:</p><ol><li>Забыл обновить коммент.</li><li>Оставил <code>console.log(&quot;TEST KEK&quot;)</code>.</li><li>Забыл TODO.</li></ol><h2 id="_16-6-высокоуровневые-комменты-проще-поддерживать" tabindex="-1"><strong>16.6 Высокоуровневые комменты проще поддерживать</strong> <a class="header-anchor" href="#_16-6-высокоуровневые-комменты-проще-поддерживать" aria-label="Permalink to &quot;**16.6 Высокоуровневые комменты проще поддерживать**&quot;">​</a></h2><p>И напоследок: комменты, которые описывают <strong>ЧТО</strong> и <strong>ЗАЧЕМ</strong> (а не <em>КАК</em>), живут дольше. Детали реализации меняются часто, а общая суть — редко. Чем абстрактнее коммент, тем реже его надо переписывать. Пиши умно, а не дословно переводи код на человеческий.</p>`,32)])])}const m=s(o,[["render",n]]);export{c as __pageData,m as default};
