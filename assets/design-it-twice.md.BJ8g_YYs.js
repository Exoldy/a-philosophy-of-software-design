import{_ as o,o as e,c as i,ae as n}from"./chunks/framework.CM3gOIkZ.js";const d=JSON.parse('{"title":"11. Проектируй дважды (Design it Twice)","description":"","frontmatter":{},"headers":[],"relativePath":"design-it-twice.md","filePath":"design-it-twice.md","lastUpdated":1769760828000}'),r={name:"design-it-twice.md"};function s(p,t,a,g,l,u){return e(),i("div",null,[...t[0]||(t[0]=[n('<h1 id="_11-проектируи-дважды-design-it-twice" tabindex="-1"><strong>11. Проектируй дважды (Design it Twice)</strong> <a class="header-anchor" href="#_11-проектируи-дважды-design-it-twice" aria-label="Permalink to &quot;**11. Проектируй дважды (Design it Twice)**&quot;">​</a></h1><p><strong>(Потому что твоя первая идея — говно)</strong></p><p>Проектирование софта — это боль, страдания и тлен. Поэтому вероятность того, что твоя первая гениальная мысль о структуре модуля окажется чем-то вменяемым, стремится к нулю. Ты получишь результат гораздо лучше, если рассмотришь несколько вариантов для каждого важного решения. Короче: <strong>спроектируй это дважды</strong>.</p><p>Допустим, ты пилишь класс, который будет управлять текстом файла для GUI-редактора. Первый шаг — определить интерфейс, который этот класс вывалит наружу для остальной части редактора. Вместо того чтобы хвататься за первую идею, которая пришла в твою светлую голову, рассмотри несколько вариантов.</p><ol><li><strong>Построчный интерфейс (Line-oriented):</strong> операции вставки, изменения и удаления целых строк.</li><li><strong>Посимвольный интерфейс:</strong> вставка и удаление отдельных символов.</li><li><strong>Строковый интерфейс (String-oriented):</strong> работа с произвольными диапазонами символов, которые могут пересекать границы строк.</li></ol><p>Тебе не нужно расписывать каждую фичу до мелочей, достаточно просто набросать основные методы на салфетке, чтобы понять, взлетит или нет.</p><p>Постарайся выбрать подходы, которые <strong>радикально, блять, отличаются</strong> друг от друга. Так ты узнаешь больше. Даже если ты уверен, что существует только один разумный подход (потому что ты у мамы самый умный), всё равно придумай второй дизайн, каким бы убогим он тебе ни казался. Будет полезно подумать о слабостях этого &quot;убогого&quot; дизайна и сравнить их с фичами других вариантов.</p><p>После того как ты накидал черновики, составь список плюсов и минусов для каждого. Самое важное соображение для интерфейса — <strong>насколько удобно этим говном пользоваться</strong> коду более высокого уровня.</p><p>В примере выше и построчный, и посимвольный интерфейсы заставят писать лишний код снаружи:</p><ul><li><strong>Построчный:</strong> заставит код верхнего уровня ебаться с разделением и склейкой строк при операциях типа cut/paste.</li><li><strong>Посимвольный:</strong> заставит писать циклы для любой операции, затрагивающей больше одного символа.</li></ul><p>Также стоит подумать о других факторах:</p><ul><li>У какого варианта интерфейс проще? (В примере с текстом они все вроде бы простые).</li><li>Какой интерфейс более универсален?</li><li>Какой интерфейс позволит реализовать всё это эффективно? (Спойлер: посимвольный подход, скорее всего, будет тормозить как твоя бывшая, потому что требует отдельного вызова на каждый, сука, символ).</li></ul><hr><p>Как только ты сравнишь альтернативы, ты будешь в лучшем положении, чтобы выбрать победителя. Лучшим выбором может стать один из вариантов, или ты внезапно поймешь, что можно скрестить ужа с ежом и получить новый дизайн, который лучше всех исходных.</p><p>Иногда бывает так, что все варианты — полное говно. Когда это случается, попробуй придумать новые схемы. Используй проблемы, которые ты нашел в первых вариантах, как топливо для нового дизайна.</p><p>Если бы ты проектировал класс текста и рассматривал только построчный и посимвольный подходы, ты бы заметил, что оба они кривые, потому что заставляют внешний код делать грязную работу. Это, блять, <strong>тревожный звоночек (Red Flag)</strong>: если уж ты делаешь класс для текста, он должен сам разгребать всё дерьмо с манипуляциями текстом. Чтобы избавиться от лишней возни снаружи, интерфейс должен плотнее соответствовать тому, что реально нужно приложению. А эти операции не всегда укладываются в &quot;один символ&quot; или &quot;одна строка&quot;. Эта логическая цепочка должна привести тебя к <strong>range-oriented API</strong> (интервальному подходу), который решает проблемы предыдущих дизайнов.</p><p>Принцип &quot;спроектируй дважды&quot; можно применять везде. Для модуля — сначала выбери интерфейс. Потом примени его снова, когда будешь думать над реализацией: связный список строк, блоки фиксированного размера или &quot;gap buffer&quot; (буфер с дыркой). Цели реализации отличаются от целей интерфейса: тут главное простота и производительность, чтобы оно летало. Также полезно перебирать варианты на высоких уровнях, например, при выборе фич для UI или при разбивке системы на крупные модули. Всегда проще найти лучший путь, если есть с чем сравнивать.</p><p>&quot;Проектирование дважды&quot; не требует дохера времени. Для небольшого класса тебе хватит часа-двух, чтобы обмозговать варианты. Это ничтожно мало по сравнению с теми днями или неделями, которые ты потратишь на кодинг (и последующий рефакторинг, если выберешь херню). Эксперименты на старте окупятся с лихвой. Для крупных модулей времени уйдет больше, но и профит от хорошего дизайна там выше.</p><h3 id="проблема-слишком-умных" tabindex="-1"><strong>Проблема &quot;слишком умных&quot;</strong> <a class="header-anchor" href="#проблема-слишком-умных" aria-label="Permalink to &quot;**Проблема &quot;слишком умных&quot;**&quot;">​</a></h3><p>Я заметил, что принцип &quot;спроектируй дважды&quot; очень туго заходит реально умным людям.</p><p>Пока они растут и учатся, эти &quot;сверхразумы&quot; привыкают, что их первая же идея достаточно хороша, чтобы получить &quot;отлично&quot; в зачетку. Нет нужды думать над вторым или третьим вариантом. Это вырабатывает херовые рабочие привычки. Однако, когда эти люди взрослеют и попадают в реальный мир (сюрприз, блять!), задачи становятся сложнее. В конце концов, все упираются в потолок, где первой идеи уже недостаточно. Если хочешь реально крутых результатов — изволь придумать второй вариант, и похер, насколько ты умен. Проектирование крупных систем — это как раз та категория: <strong>никто не настолько крут, чтобы сделать всё правильно с первого раза</strong>.</p><p>К сожалению, я часто вижу умников, которые с пеной у рта настаивают на реализации первой пришедшей в голову идеи. Это заставляет их работать хуже своего потенциала (а еще с ними пиздец как сложно работать, они бесят). Возможно, они подсознательно верят, что &quot;умные люди делают всё правильно с первого раза&quot;, поэтому, если они пробуют несколько вариантов, это типа значит, что они тупые.</p><p>Это не так. Дело не в том, что ты тупой, а в том, что задачи, сука, сложные! И это даже хорошо: гораздо интереснее решать сложную задачу, где надо шевелить извилинами, чем клепать формочки, где думать вообще не надо.</p><p>Подход &quot;спроектируй дважды&quot; не только улучшает твой дизайн, но и качает твой скилл. Процесс сравнения подходов научит тебя видеть факторы, которые делают дизайн хорошим или куском говна. Со временем тебе станет проще отсеивать лажу и сразу целиться в нормальные решения.</p>',24)])])}const c=o(r,[["render",s]]);export{d as __pageData,c as default};
