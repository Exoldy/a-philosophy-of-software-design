import{_ as t,o as a,c as o,ae as i}from"./chunks/framework.CM3gOIkZ.js";const u=JSON.parse('{"title":"10. Ошибок не существует (Define Errors Out of Existence)","description":"","frontmatter":{},"headers":[],"relativePath":"define-errors-out-of-existence.md","filePath":"define-errors-out-of-existence.md","lastUpdated":1769759266000}'),e={name:"define-errors-out-of-existence.md"};function n(r,s,l,p,c,h){return a(),o("div",null,[...s[0]||(s[0]=[i(`<h1 id="_10-ошибок-не-существует-define-errors-out-of-existence" tabindex="-1"><strong>10. Ошибок не существует (Define Errors Out of Existence)</strong> <a class="header-anchor" href="#_10-ошибок-не-существует-define-errors-out-of-existence" aria-label="Permalink to &quot;**10. Ошибок не существует (Define Errors Out of Existence)**&quot;">​</a></h1><p>Обработка исключений — это один из самых жирных источников сложности в софте. Код, который разгребает дерьмо (особые условия), писать сложнее, чем код, который просто делает работу. Разработчики часто объявляют исключения, вообще не отдупляя, как их потом будут обрабатывать. Эта глава пояснит, почему исключения — это зло, и покажет, как сделать так, чтобы их было поменьше.</p><p><strong>Спойлер:</strong> Главная мысль главы — сократи количество мест, где нужно подтирать за кодом. В идеале — измени семантику операций так, чтобы &quot;ошибок&quot; тупо не существовало.</p><h2 id="_10-1-почему-exception-увеличивает-сложность-потому-что-ты-их-не-обрабатываешь" tabindex="-1"><strong>10.1 Почему Exception увеличивает сложность (Потому что ты их не обрабатываешь)</strong> <a class="header-anchor" href="#_10-1-почему-exception-увеличивает-сложность-потому-что-ты-их-не-обрабатываешь" aria-label="Permalink to &quot;**10.1 Почему Exception увеличивает сложность (Потому что ты их не обрабатываешь)**&quot;">​</a></h2><p>Под &quot;исключением&quot; я понимаю любую херню, которая прерывает нормальный поток выполнения программы. Это может быть <code>throw</code> в языке, а может быть спец-значение (типа вернуть <code>-1</code>, когда ждали позитив). И то, и другое — боль.</p><p>Откуда прилетает этот нежданчик:</p><ul><li>Вызывающий код передал кривые аргументы (руки из жопы).</li><li>Метод не смог сделать работу (I/O сдох, ресурса нет).</li><li>В распределенной системе пакеты потерялись или сервер ушел в запой.</li><li>Код нашел баг или несогласованность внутри себя.</li></ul><p>Код обработки ошибок писать сложнее, чем обычный. Исключение ломает флоу. У тебя два пути, и оба хреновые:</p><ol><li><strong>Попытаться починить и продолжить.</strong> (Типа переслать пакет). Но это может привести к дублям или бесконечным циклам ада.</li><li><strong>Бросить всё и умереть (abort).</strong> Но тогда надо откатывать состояние системы, иначе оставишь после себя битые структуры данных.</li></ol><p>Более того, код обработки ошибок часто <strong>сам генерирует новые ошибки</strong>. Пытался восстановить данные из бэкапа? А бэкап тоже битый. Поздравляю, ты в рекурсивной жопе.</p><p>Языковая поддержка исключений (особенно в Java) — это отдельный вид пытки. Взгляните на этот кусок кода для чтения твитов:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Три строчки полезного кода</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (FileNotFoundException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { ... }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ClassNotFoundException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { ... }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (IOException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { ... }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ClassCastException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { ... }</span></span></code></pre></div><p>Бойлерплейта больше, чем логики. Читать это невозможно.</p><p>А самое веселое: <strong>код обработки ошибок почти невозможно протестировать</strong>. Эти ситуации на проде случаются раз в год, поэтому код хендлеров никогда не исполняется. А как гласит народная мудрость: &quot;Код, который не запускался — не работает&quot;. 90% катастрофических падений распределенных систем случаются из-за кривой обработки ошибок.</p><h2 id="_10-2-слишком-дохера-исключении" tabindex="-1"><strong>10.2 Слишком дохера исключений</strong> <a class="header-anchor" href="#_10-2-слишком-дохера-исключении" aria-label="Permalink to &quot;**10.2 Слишком дохера исключений**&quot;">​</a></h2><p>Программисты сами роют себе могилу, создавая лишние исключения. Нас учат: &quot;Отлавливай ошибки! Будь бдителен!&quot;. И начинается защитное программирование головного мозга: чуть что не так — кидаем эксепшн.</p><p>Я сам так обосрался, когда делал язык <strong>Tcl</strong>. Команда <code>unset</code> (удалить переменную) кидала ошибку, если переменной не существовало. Я думал: &quot;Ну это же баг, если удаляют то, чего нет!&quot;. А на практике <code>unset</code> часто используют для очистки мусора. И программистам приходилось оборачивать удаление в <code>catch</code>, чтобы скрипт не падал. Это была одна из моих самых тупых ошибок в дизайне.</p><p>Исключение — это часть интерфейса. Класс, который плюется ошибками на каждый чих — сложный и ненадежный.</p><h2 id="_10-3-спроектируи-так-чтобы-ошибки-не-возникали" tabindex="-1"><strong>10.3 Спроектируй так, чтобы ошибки не возникали</strong> <a class="header-anchor" href="#_10-3-спроектируи-так-чтобы-ошибки-не-возникали" aria-label="Permalink to &quot;**10.3 Спроектируй так, чтобы ошибки не возникали**&quot;">​</a></h2><p>Лучший способ не обрабатывать исключения — сделать так, чтобы их не было. Вернемся к моему факапу с <code>unset</code>. Надо было просто изменить определение: <code>unset</code> не &quot;удаляет переменную&quot;, а &quot;обеспечивает, чтобы переменной не было&quot;. Если переменной и так нет — задача выполнена. Успех. Ошибки не существует. Профит.</p><h2 id="_10-4-пример-удаление-фаила-в-windows-ад-vs-unix-раи" tabindex="-1"><strong>10.4 Пример: Удаление файла в Windows (Ад) vs Unix (Рай)</strong> <a class="header-anchor" href="#_10-4-пример-удаление-фаила-в-windows-ад-vs-unix-раи" aria-label="Permalink to &quot;**10.4 Пример: Удаление файла в Windows (Ад) vs Unix (Рай)**&quot;">​</a></h2><p><strong>Windows:</strong> Если файл открыт процессом, хер ты его удалишь. Это бесконечный источник боли. Юзеру надо искать, какой процесс держит файл, убивать его, или ребутать комп. <strong>Unix:</strong> Если файл открыт, Unix помечает его &quot;на удаление&quot; и возвращает успех. Имя файла исчезает из папки (новые процессы его не найдут), но старые процессы спокойно дочитывают данные. Когда все закроют файл — он исчезнет физически.</p><p>Unix просто взял и определил две ошибки как &quot;не ошибки&quot;:</p><ol><li>Удаление занятого файла — теперь ОК.</li><li>Чтение удаленного файла текущими процессами — теперь ОК.</li></ol><p>В итоге: меньше геморроя, меньше кода, все счастливы.</p><h2 id="_10-5-пример-java-substring-как-выстрелить-себе-в-ногу" tabindex="-1"><strong>10.5 Пример: Java substring (Как выстрелить себе в ногу)</strong> <a class="header-anchor" href="#_10-5-пример-java-substring-как-выстрелить-себе-в-ногу" aria-label="Permalink to &quot;**10.5 Пример: Java substring (Как выстрелить себе в ногу)**&quot;">​</a></h2><p>Метод <code>substring</code> в Java — это истеричка. Если ты попросишь подстроку, выходящую за границы, он кинет <code>IndexOutOfBoundsException</code>. Зачем? Мне часто нужно просто &quot;дай мне всё, что есть в этом диапазоне&quot;. Приходится писать 10 строк проверок индексов. Нормальный API (как срезы в Python) просто возвращает пересечение запрошенного диапазона и строки. Если индексы за пределами — верни пустую строку или то, что влезло. Ошибки нет, код чище.</p><p>Аргумент &quot;а вдруг это баг, надо сообщить!&quot; — слабый. Выкидывание исключений увеличивает сложность, а сложность порождает еще больше багов.</p><h2 id="_10-6-маскировка-исключении-типа-ничего-не-случилось" tabindex="-1"><strong>10.6 Маскировка исключений (Типа ничего не случилось)</strong> <a class="header-anchor" href="#_10-6-маскировка-исключении-типа-ничего-не-случилось" aria-label="Permalink to &quot;**10.6 Маскировка исключений (Типа ничего не случилось)**&quot;">​</a></h2><p>Второй метод: решай проблемы на низком уровне, чтобы &quot;начальство&quot; (верхний уровень кода) не знало.</p><ul><li><strong>TCP:</strong> Если пакет потерялся, протокол сам его перепошлет. Приложению вообще пофиг, оно думает, что сеть идеальна.</li><li><strong>NFS (Сетевая файловая система):</strong> Если сервер завис, клиент NFS просто... виснет. Он будет долбиться в сервер до посинения. Юзеры ноют, что приложение &quot;зависло&quot;. Но альтернатива — выкинуть ошибку. И что приложение будет с ней делать? Скорее всего, упадет. А так, сервер очнется, и всё продолжит работать, как ни в чем не бывало.</li></ul><p>Это пример &quot;спускания сложности вниз&quot;. Класс становится глубже, интерфейс проще.</p><h2 id="_10-7-агрегация-исключении" tabindex="-1"><strong>10.7 Агрегация исключений</strong> <a class="header-anchor" href="#_10-7-агрегация-исключении" aria-label="Permalink to &quot;**10.7 Агрегация исключений**&quot;">​</a></h2><p>Третий метод: обрабатывай кучу разных ошибок в одном месте.</p><p>Представьте веб-сервер. У него куча обработчиков URL. Каждый достает параметры. Если параметра нет — ошибка. <strong>Плохой путь:</strong> В каждом методе свой <code>try-catch</code>. Куча дубликатов. <strong>Хороший путь:</strong> Пусть исключение летит на самый верх. Там, в главном цикле диспетчера, стоит один глобальный <code>try-catch</code>, который ловит всё и отдает клиенту красивый HTTP 400/500.</p><p>Пример из <strong>RAMCloud</strong>: У них есть сложный механизм восстановления после падения сервера (восстанавливают данные с других нод). А что делать, если найден <em>один</em> битый объект? Они решили не писать отдельный код для восстановления одного объекта. Они просто <strong>крашат сервер</strong>, на котором нашли битый объект. Звучит дико? Да. Но это позволяет использовать <em>уже написанный и отлаженный</em> механизм восстановления сервера. Мы превращаем мелкую ошибку в крупную, чтобы обработать её общим механизмом.</p><h2 id="_10-8-а-может-просто-крашнуться-иногда-лучше-сдохнуть-сразу" tabindex="-1"><strong>10.8 А может, просто крашнуться? (Иногда лучше сдохнуть сразу)</strong> <a class="header-anchor" href="#_10-8-а-может-просто-крашнуться-иногда-лучше-сдохнуть-сразу" aria-label="Permalink to &quot;**10.8 А может, просто крашнуться? (Иногда лучше сдохнуть сразу)**&quot;">​</a></h2><p>Четвертый метод: <strong>Abort.</strong> Некоторые ошибки не стоит пытаться обрабатывать. Пример: <code>malloc</code> в C возвращает <code>NULL</code>, если память кончилась. Это заставляет проверять каждый чих. Если у тебя в 2024 году кончилась память — твоему приложению пизда. Не надо пытаться выжить, освобождая кэши. Скорее всего, это баг. Просто напиши обертку <code>ckalloc</code>, которая при неудаче пишет в лог &quot;Всё пропало&quot; и убивает процесс.</p><p>То же самое с &quot;невозможными&quot; состояниями (internal inconsistency). Если структура данных сломана — это баг. Не лови его, пусть падает. Это честнее и безопаснее, чем работать с битыми данными.</p><h2 id="_10-9-убираем-особые-случаи-special-cases" tabindex="-1"><strong>10.9 Убираем &quot;особые случаи&quot; (Special cases)</strong> <a class="header-anchor" href="#_10-9-убираем-особые-случаи-special-cases" aria-label="Permalink to &quot;**10.9 Убираем &quot;особые случаи&quot; (Special cases)**&quot;">​</a></h2><p>Спец-кейсы порождают <code>if</code>-ы. <code>If</code>-ы порождают баги. Пример: Текстовый редактор. Студенты часто делают переменную &quot;выделение&quot;, которая может быть <code>null</code>, если ничего не выделено. В итоге весь код засран проверками <code>if (selection != null)</code>. <strong>Решение:</strong> Выделение есть всегда. Просто иногда его длина = 0. Удалить пустое выделение? Легко, удаляем 0 байт. Копировать? Копируем 0 байт. Логика &quot;нет выделения&quot; нужна юзеру, а не коду. Внутри кода объект должен быть всегда.</p><h2 id="_10-10-taking-it-too-far" tabindex="-1"><strong>10.10 Taking it too far</strong> <a class="header-anchor" href="#_10-10-taking-it-too-far" aria-label="Permalink to &quot;**10.10 Taking it too far**&quot;">​</a></h2><p>Убирать ошибки — это круто, но не надо быть идиотом. Одни студенты в сетевом модуле глотали <em>все</em> ошибки. Сеть лежит? Похер, делаем вид, что отправили. В итоге приложение не знает, что данные не дошли. Это уже не упрощение, это саботаж. Важные ошибки (информация о которых нужна для принятия решений) скрывать нельзя.</p><h2 id="_10-11-итог" tabindex="-1"><strong>10.11 Итог</strong> <a class="header-anchor" href="#_10-11-итог" aria-label="Permalink to &quot;**10.11 Итог**&quot;">​</a></h2><p>Спец-кейсы и исключения — это рак кода.</p><ol><li>Переопредели семантику так, чтобы ошибок не существовало (пример с <code>unset</code> и удалением файлов).</li><li>Маскируй ошибки на нижнем уровне (как TCP).</li><li>Агрегируй обработку в одном месте.</li><li>Если всё плохо — падай.</li></ol><p>Чем меньше у тебя <code>catch</code> блоков, тем крепче твой сон.</p>`,47)])])}const g=t(e,[["render",n]]);export{u as __pageData,g as default};
